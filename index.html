<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inventory System</title>
    <style>
        :root {
            /* Light theme (default) */
            --bg-color: #f5f5f5;
            --container-bg: #ffffff;
            --text-color: #333333;
            --border-color: #dddddd;
            --header-bg: #f8f8f8;
            --highlight-bg: #f5f5f5;
            --button-primary: #4CAF50;
            --button-primary-hover: #45a049;
            --button-secondary: #2196F3;
            --button-secondary-hover: #1976D2;
            --button-danger: #ff4444;
            --button-danger-hover: #cc0000;
            --location-quantity-bg: #e3f2fd;
            --location-quantity-color: #1976D2;
            --location-quantity-current-bg: #c8e6c9;
            --location-quantity-current-color: #2e7d32;
            --history-item-border: #eee;
            --shadow-color: rgba(0,0,0,0.1);
            --toggle-icon: 'üåô';
        }

        [data-theme="dark"] {
            /* Dark theme */
            --bg-color: #121212;
            --container-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --border-color: #444444;
            --header-bg: #2a2a2a;
            --highlight-bg: #333333;
            --button-primary: #388E3C;
            --button-primary-hover: #2E7D32;
            --button-secondary: #1976D2;
            --button-secondary-hover: #1565C0;
            --button-danger: #d32f2f;
            --button-danger-hover: #b71c1c;
            --location-quantity-bg: #0d47a1;
            --location-quantity-color: #e3f2fd;
            --location-quantity-current-bg: #1b5e20;
            --location-quantity-current-color: #c8e6c9;
            --history-item-border: #444444;
            --shadow-color: rgba(0,0,0,0.4);
            --toggle-icon: '‚òÄÔ∏è';
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        body {
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: var(--container-bg);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        .top-actions {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .data-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .action-btn {
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            border: none;
            font-weight: bold;
        }
        
        .action-btn.export {
            background-color: #673AB7;
            color: white;
        }
        
        .action-btn.import {
            background-color: #FF9800;
            color: white;
        }
        
        .theme-toggle {
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            border: none;
            background-color: var(--button-secondary);
            color: white;
            margin-left: 10px;
        }

        .user-selector {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .user-selector select {
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 16px;
            min-width: 150px;
            background-color: var(--container-bg);
            color: var(--text-color);
        }

        .user-selector label {
            font-weight: bold;
            color: var(--text-color);
        }
        
        .user-btn {
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            background-color: var(--button-secondary);
            color: white;
            border: none;
        }
        
        .user-btn.add {
            background-color: var(--button-primary);
        }
        
        .user-btn.delete {
            background-color: var(--button-danger);
        }

        h1 {
            color: var(--text-color);
            margin-bottom: 20px;
            text-align: center;
        }

        .search-container {
            margin-bottom: 20px;
        }

        #searchInput {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-bottom: 10px;
            background-color: var(--container-bg);
            color: var(--text-color);
        }

        .add-item-form {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .add-item-form input {
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--container-bg);
            color: var(--text-color);
        }

        button {
            padding: 8px 16px;
            background-color: var(--button-primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: var(--button-primary-hover);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background-color: var(--header-bg);
            font-weight: bold;
        }

        tr:hover {
            background-color: var(--highlight-bg);
        }

        .history-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid var(--history-item-border);
        }

        .quantity-btn {
            padding: 4px 8px;
            margin: 0 4px;
            background-color: var(--button-secondary);
        }

        .quantity-btn:hover {
            background-color: var(--button-secondary-hover);
        }

        .item-row {
            position: relative;
        }

        .item-details {
            display: none;
            background: var(--container-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 15px;
            margin-top: 10px;
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        .item-details.show {
            display: block;
        }

        .item-details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .item-details-section {
            margin-bottom: 10px;
        }

        .item-details-section label {
            display: block;
            margin-bottom: 5px;
            color: var(--text-color);
        }

        .item-details-section textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            resize: vertical;
            min-height: 60px;
            background-color: var(--container-bg);
            color: var(--text-color);
        }

        .item-details-section select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--container-bg);
            color: var(--text-color);
        }

        .item-details-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .item-details-buttons button {
            flex: 1;
        }

        .toggle-details-btn {
            background: none;
            border: none;
            color: var(--button-secondary);
            cursor: pointer;
            padding: 4px 8px;
            font-size: 20px;
        }

        .toggle-details-btn:hover {
            color: var(--button-secondary-hover);
        }

        .location-selector {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .location-selector select {
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 16px;
            background-color: var(--container-bg);
            color: var(--text-color);
        }

        .location-selector .location-name {
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 16px;
            width: 200px;
            background-color: var(--container-bg);
            color: var(--text-color);
        }

        .location-selector button {
            background-color: var(--button-primary);
        }

        .location-selector button.delete {
            background-color: var(--button-danger);
        }

        .location-quantities {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 4px;
            font-size: 0.9em;
        }

        .location-quantity {
            background-color: var(--location-quantity-bg);
            padding: 2px 6px;
            border-radius: 3px;
            color: var(--location-quantity-color);
        }

        .location-quantity.current {
            background-color: var(--location-quantity-current-bg);
            color: var(--location-quantity-current-color);
        }

        .item-details-row {
            background-color: var(--header-bg);
        }

        .item-details-row .item-details {
            margin: 0;
            border: none;
            box-shadow: none;
        }

        .total-quantity {
            font-weight: bold;
            margin-bottom: 8px;
        }

        .location-quantities-list {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .location-quantity-item {
            display: flex;
            align-items: center;
            gap: 5px;
            background-color: var(--highlight-bg);
            padding: 3px 6px;
            border-radius: 4px;
            margin-bottom: 4px;
        }

        .location-quantity-item.current {
            background-color: var(--location-quantity-bg);
            border-left: 3px solid var(--location-quantity-color);
        }

        .quantity-controls {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .quantity-value {
            min-width: 20px;
            text-align: center;
            cursor: pointer;
            font-weight: bold;
        }

        .quantity-value:hover {
            background-color: var(--highlight-bg);
            border-radius: 2px;
        }

        .no-results {
            padding: 15px;
            text-align: center;
            color: var(--text-color);
            font-style: italic;
            background-color: var(--header-bg);
            border-radius: 4px;
            margin: 10px 0;
        }

        /* Floor Plan Styles */
        .floor-plan-button {
            background-color: var(--button-secondary);
            margin-left: 10px;
        }

        .floor-plan-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
        }

        .floor-plan-content {
            background-color: var(--container-bg);
            margin: 5% auto;
            padding: 20px;
            width: 90%;
            max-width: 1000px;
            border-radius: 8px;
            box-shadow: 0 4px 8px var(--shadow-color);
            position: relative;
            color: var(--text-color);
        }

        .floor-plan-close {
            position: absolute;
            right: 20px;
            top: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: var(--text-color);
        }

        .floor-plan-editor {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .floor-plan-tools {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            padding: 10px;
            background-color: var(--highlight-bg);
            border-radius: 4px;
        }

        .floor-plan-canvas-container {
            border: 1px solid var(--border-color);
            background-color: var(--bg-color);
            min-height: 500px;
            overflow: auto;
            position: relative;
        }

        #floorPlanCanvas {
            background-color: var(--container-bg);
            box-shadow: 0 0 5px var(--shadow-color);
        }

        .shape-button {
            padding: 8px 12px;
            background-color: var(--highlight-bg);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-color);
        }

        .shape-button.active {
            background-color: var(--button-secondary);
            color: white;
        }

        .color-picker {
            height: 30px;
            width: 30px;
            padding: 0;
            border: 1px solid var(--border-color);
        }

        .product-placement-panel {
            margin-top: 15px;
            padding: 10px;
            background-color: var(--highlight-bg);
            border-radius: 4px;
        }

        .product-placement-list {
            height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            border: 1px solid var(--border-color);
            background-color: var(--container-bg);
        }

        .product-item {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-color);
        }

        .product-item:hover {
            background-color: var(--highlight-bg);
        }

        .placed-product {
            position: absolute;
            background-color: rgba(33, 150, 243, 0.7);
            color: white;
            padding: 5px;
            border-radius: 3px;
            font-size: 12px;
            cursor: move;
            z-index: 10;
        }

        .floor-plan-actions {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }

        /* Enhance user selector on smaller screens */
        @media (max-width: 768px) {
            .top-actions {
                flex-direction: column;
            }
            .user-selector, .data-actions {
                width: 100%;
            }
        }

        /* Barcode Scanner Styles */
        .scanner-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
        }
        
        .scanner-content {
            background-color: var(--container-bg);
            margin: 5% auto;
            padding: 20px;
            width: 90%;
            max-width: 600px;
            border-radius: 8px;
            box-shadow: 0 4px 8px var(--shadow-color);
            position: relative;
            color: var(--text-color);
        }
        
        .scanner-close {
            position: absolute;
            right: 20px;
            top: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: var(--text-color);
        }
        
        #scanner-container {
            width: 100%;
            height: 300px;
            position: relative;
            overflow: hidden;
            border-radius: 4px;
            background-color: #000;
        }
        
        #scanner-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #scanner-canvas {
            display: none;
        }
        
        .scanner-controls {
            margin-top: 15px;
            display: flex;
            justify-content: space-between;
        }
        
        .scanner-status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            background-color: var(--highlight-bg);
            text-align: center;
        }
        
        .scanner-status.success {
            background-color: var(--location-quantity-current-bg);
            color: var(--location-quantity-current-color);
        }
        
        .scanner-status.error {
            background-color: var(--button-danger);
            color: white;
        }
        
        .scanner-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .scanner-buttons button {
            flex: 1;
        }
        
        .scanner-buttons button.switch-camera {
            background-color: var(--button-secondary);
        }
        
        .scanner-buttons button.switch-camera:hover {
            background-color: var(--button-secondary-hover);
        }

        /* Theme Toggle Styles */
        .theme-toggle-container {
            display: flex;
            align-items: center;
            margin-left: 10px;
        }
        
        .theme-toggle-label {
            margin-right: 8px;
            font-size: 16px;
        }
        
        .theme-toggle {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .theme-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .theme-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .theme-toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .theme-toggle-slider {
            background-color: var(--button-secondary);
        }
        
        input:checked + .theme-toggle-slider:before {
            transform: translateX(26px);
        }
        
        /* Scan Barcode Button Style */
        .action-btn.scan-barcode {
            background-color: #009688;
        }
        
        .action-btn.scan-barcode:hover {
            background-color: #00796b;
        }
        
        /* Barcode Assignment Button */
        .barcode-btn {
            padding: 4px 8px;
            background-color: var(--button-secondary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 5px;
            font-size: 12px;
        }
        
        .barcode-btn:hover {
            background-color: var(--button-secondary-hover);
        }
        
        /* Barcode Assignment Modal */
        .barcode-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
        }
        
        .barcode-content {
            background-color: var(--container-bg);
            margin: 5% auto;
            padding: 20px;
            width: 90%;
            max-width: 500px;
            border-radius: 8px;
            box-shadow: 0 4px 8px var(--shadow-color);
            position: relative;
            color: var(--text-color);
        }
        
        .barcode-close {
            position: absolute;
            right: 20px;
            top: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: var(--text-color);
        }
        
        .barcode-form {
            margin-top: 20px;
        }
        
        .barcode-form input {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--container-bg);
            color: var(--text-color);
        }
        
        .barcode-form button {
            width: 100%;
        }

        /* Settings Modal Styles */
        .settings-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
        }
        
        .settings-content {
            background-color: var(--container-bg);
            margin: 5% auto;
            padding: 20px;
            width: 90%;
            max-width: 600px;
            border-radius: 8px;
            box-shadow: 0 4px 8px var(--shadow-color);
            position: relative;
            color: var(--text-color);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .settings-close {
            position: absolute;
            right: 20px;
            top: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: var(--text-color);
        }
        
        .settings-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .settings-tab {
            padding: 10px 15px;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-color);
            font-weight: bold;
            opacity: 0.7;
            transition: opacity 0.3s;
        }
        
        .settings-tab:hover {
            opacity: 1;
        }
        
        .settings-tab.active {
            opacity: 1;
            border-bottom: 2px solid var(--button-secondary);
        }
        
        .settings-panel {
            display: none;
        }
        
        .settings-panel.active {
            display: block;
        }
        
        .settings-item {
            margin-bottom: 20px;
        }
        
        .settings-item label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        .settings-input-group {
            display: flex;
            gap: 10px;
        }
        
        .settings-input-group input {
            flex: 1;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--container-bg);
            color: var(--text-color);
        }
        
        .settings-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--container-bg);
        }
        
        .settings-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .settings-list-item:last-child {
            border-bottom: none;
        }
        
        .settings-list-item .item-actions {
            display: flex;
            gap: 5px;
        }
        
        .settings-list-item .item-actions button {
            padding: 4px 8px;
            font-size: 12px;
        }
        
        .danger-btn {
            background-color: var(--button-danger);
        }
        
        .danger-btn:hover {
            background-color: var(--button-danger-hover);
        }
        
        /* Settings Button Style */
        .action-btn.settings-btn {
            background-color: #607D8B;
        }
        
        .action-btn.settings-btn:hover {
            background-color: #455A64;
        }

        .shape-button.delete-tool {
            background-color: #ff4444;
            color: white;
        }
        
        .delete-cursor {
            cursor: crosshair;
        }
        
        /* Style for delete button when active */
        .shape-button.delete-tool {
            background-color: #ff4444;
            color: white;
            font-weight: bold;
        }
        
        .item-details-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .barcode-display {
            font-family: monospace;
            background-color: rgba(0,0,0,0.05);
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.9em;
            display: inline-block;
        }
        
        .small-btn {
            padding: 2px 5px;
            font-size: 0.8em;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .small-btn:hover {
            background-color: #e9ecef;
        }
        
        .scanner-result {
            margin-top: 15px;
            padding: 10px;
            font-weight: bold;
            text-align: center;
        }
        
        .product-result {
            margin-top: 10px;
            padding: 10px;
        }
        
        .alert {
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 4px;
        }
        
        .alert-success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        
        .alert-warning {
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
        }
        
        .btn {
            display: inline-block;
            padding: 6px 12px;
            margin: 5px 3px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid transparent;
        }
        
        .btn-primary {
            background-color: #007bff;
            border-color: #007bff;
            color: white;
        }
        
        .btn-secondary {
            background-color: #6c757d;
            border-color: #6c757d;
            color: white;
        }
        
        .mt-3 {
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Inventory System</h1>
        
        <div class="top-actions">
            <div class="user-select">
                <span>Current User: </span>
                <select id="userSelect" onchange="changeUser(this.value)">
                </select>
            </div>
            <div class="location-select">
                <span>Current Location: </span>
                <select id="locationSelect" onchange="changeLocation(this.value)">
                </select>
                <button onclick="openFloorPlan()" class="floor-plan-button">Floor Plan</button>
            </div>
            <div class="data-actions">
                <button onclick="openBarcodeScanner()">Scan Barcode</button>
                <button onclick="openSettings()">‚öôÔ∏è Settings</button>
            </div>
        </div>

        <div class="search-container">
            <input type="text" id="searchInput" placeholder="Search items...">
        </div>

        <div class="add-item-form">
            <input type="text" id="itemName" placeholder="Item Name">
            <input type="number" id="itemQuantity" placeholder="Quantity">
            <input type="number" id="itemPrice" placeholder="Price">
            <button onclick="addItem()">Add Item</button>
        </div>

        <table id="inventoryTable">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Quantity</th>
                    <th>Price</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="inventoryBody"></tbody>
        </table>

        <div class="history-section">
            <h2>Change History</h2>
            <div id="historyList"></div>
        </div>
    </div>

    <!-- Floor Plan Modal -->
    <div id="floorPlanModal" class="floor-plan-modal">
        <div class="floor-plan-content">
            <span class="floor-plan-close" onclick="closeFloorPlan()">&times;</span>
            <h2>Floor Plan - <span id="floorPlanLocationName"></span></h2>
            
            <div class="floor-plan-editor">
                <div class="floor-plan-tools">
                    <button class="shape-button active" data-tool="select" onclick="selectTool('select')">Select</button>
                    <button class="shape-button" data-tool="rectangle" onclick="selectTool('rectangle')">Rectangle</button>
                    <button class="shape-button" data-tool="circle" onclick="selectTool('circle')">Circle</button>
                    <button class="shape-button" data-tool="text" onclick="selectTool('text')">Text</button>
                    <button class="shape-button" data-tool="delete" onclick="selectTool('delete')">Delete</button>
                    <input type="color" class="color-picker" id="shapeColor" value="#CCCCCC">
                    <div style="flex-grow: 1;"></div>
                    <button onclick="clearFloorPlan()">Clear All</button>
                </div>
                
                <div class="floor-plan-canvas-container">
                    <div id="floorPlanCanvas" style="width: 1000px; height: 600px;"></div>
                    <div id="placedProducts"></div>
                </div>
                
                <div class="product-placement-panel">
                    <h3>Place Products on Floor Plan</h3>
                    <p>Drag products onto the floor plan to show their locations</p>
                    <div class="product-placement-list" id="productList"></div>
                </div>
                
                <div class="floor-plan-actions">
                    <button onclick="saveFloorPlan()">Save Floor Plan</button>
                    <button onclick="viewFloorPlan()">View Mode</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add this after the floor plan modal -->
    <div id="scannerModal" class="scanner-modal">
        <div class="scanner-content">
            <span class="scanner-close" onclick="closeBarcodeScanner()">&times;</span>
            <h2>Scan Barcode</h2>
            
            <div id="scanner-container">
                <video id="video" autoplay playsinline></video>
                <canvas id="scanner-canvas"></canvas>
            </div>
            
            <div id="scannerResult" class="scanner-result"></div>
            <div id="productResult" class="product-result"></div>
            
            <div class="scanner-status" id="scanner-status">Ready to scan...</div>
            
            <div class="scanner-buttons">
                <button onclick="switchCamera()" class="switch-camera">Switch Camera</button>
                <button onclick="closeBarcodeScanner()">Close</button>
            </div>
        </div>
    </div>

    <!-- Add the barcode assignment modal -->
    <div id="barcodeModal" class="barcode-modal">
        <div class="barcode-content">
            <span class="barcode-close" onclick="closeBarcodeModal()">&times;</span>
            <h2>Assign Barcode</h2>
            <p id="barcodeProductName"></p>
            
            <div class="barcode-form">
                <input type="text" id="barcodeInput" placeholder="Enter barcode">
                <button onclick="saveBarcode()">Save Barcode</button>
            </div>
        </div>
    </div>

    <!-- Add settings modal -->
    <div id="settingsModal" class="settings-modal">
        <div class="settings-content">
            <span class="settings-close" onclick="closeSettings()">&times;</span>
            <h2>Settings</h2>
            
            <div class="settings-tabs">
                <button class="settings-tab active" onclick="switchSettingsTab('theme')">Theme</button>
                <button class="settings-tab" onclick="switchSettingsTab('data')">Data</button>
                <button class="settings-tab" onclick="switchSettingsTab('users')">Users</button>
                <button class="settings-tab" onclick="switchSettingsTab('locations')">Locations</button>
            </div>
            
            <div id="themeSettings" class="settings-panel active">
                <h3>Theme Settings</h3>
                <div class="settings-item">
                    <label>Dark Mode</label>
                    <div class="theme-toggle-container">
                        <label class="theme-toggle-label">üåô</label>
                        <label class="theme-toggle">
                            <input type="checkbox" id="settingsThemeCheckbox" onchange="toggleThemeFromSettings()">
                            <span class="theme-toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div id="dataSettings" class="settings-panel">
                <h3>Data Management</h3>
                <div class="settings-item">
                    <label>Export Data</label>
                    <button onclick="exportData()">Export to JSON</button>
                </div>
                <div class="settings-item">
                    <label>Import Data</label>
                    <button onclick="importData()">Import from JSON</button>
                    <input type="file" id="settingsImportFile" accept=".json" style="display: none;" onchange="handleImportFile(event)">
                </div>
                <div class="settings-item">
                    <label>Clear All Data</label>
                    <button onclick="confirmClearData()" class="danger-btn">Clear Database</button>
                </div>
            </div>
            
            <div id="usersSettings" class="settings-panel">
                <h3>User Management</h3>
                <div class="settings-item">
                    <label>Add New User</label>
                    <div class="settings-input-group">
                        <input type="text" id="newUserName" placeholder="User Name">
                        <button onclick="addUserFromSettings()">Add</button>
                    </div>
                </div>
                <div class="settings-item">
                    <label>Existing Users</label>
                    <div id="usersList" class="settings-list"></div>
                </div>
            </div>
            
            <div id="locationsSettings" class="settings-panel">
                <h3>Location Management</h3>
                <div class="settings-item">
                    <label>Add New Location</label>
                    <div class="settings-input-group">
                        <input type="text" id="newLocationName" placeholder="Location Name">
                        <button onclick="addLocationFromSettings()">Add</button>
                    </div>
                </div>
                <div class="settings-item">
                    <label>Existing Locations</label>
                    <div id="locationsList" class="settings-list"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/idb@8/build/umd.js"></script>
    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <script type="module">
        import { BrowserMultiFormatReader, NotFoundException } from 'https://cdn.jsdelivr.net/npm/@zxing/library@0.21.3/+esm';
        window.BrowserMultiFormatReader = BrowserMultiFormatReader;
        window.NotFoundException = NotFoundException;
    </script>

    <script >

        let products = [];
        let inventoryItems = [];
        let locations = [];
        let transactions = [];
        let users = [];
        let currentLocation = '';
        let currentUser = 'User 1';
        let currentUserId = '';
        let db;
        let currentTheme = localStorage.getItem('theme') || 'light';

        // Set up theme on initial load
        function applyTheme() {
            if (currentTheme === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark');
                // Update both checkboxes if they exist
                const mainCheckbox = document.getElementById('themeCheckbox');
                const settingsCheckbox = document.getElementById('settingsThemeCheckbox');
                
                if (mainCheckbox) mainCheckbox.checked = true;
                if (settingsCheckbox) settingsCheckbox.checked = true;
                
                document.querySelector('.theme-toggle-label').textContent = '‚òÄÔ∏è';
            } else {
                document.documentElement.setAttribute('data-theme', 'light');
                // Update both checkboxes if they exist
                const mainCheckbox = document.getElementById('themeCheckbox');
                const settingsCheckbox = document.getElementById('settingsThemeCheckbox');
                
                if (mainCheckbox) mainCheckbox.checked = false;
                if (settingsCheckbox) settingsCheckbox.checked = false;
                
                document.querySelector('.theme-toggle-label').textContent = 'üåô';
            }
        }

        // Apply theme immediately
        applyTheme();

        // Toggle between light and dark mode
        function toggleTheme() {
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            localStorage.setItem('theme', currentTheme);
            applyTheme();
        }

        // Toggle theme from settings
        function toggleThemeFromSettings() {
            toggleTheme();
        }

        const initDB = async () => {
            try {
                db = await idb.openDB('inventoryDB', 4, {
                    upgrade(db, oldVersion, newVersion, transaction) {
                        console.log(`Upgrading database from version ${oldVersion} to ${newVersion}`);
                        
                        // Create object stores matching the schema in README
                        if (!db.objectStoreNames.contains('products')) {
                            const productStore = db.createObjectStore('products', { keyPath: 'id' });
                            productStore.createIndex('name', 'name', { unique: false });
                        }
                        
                    if (!db.objectStoreNames.contains('locations')) {
                            const locationStore = db.createObjectStore('locations', { keyPath: 'id' });
                            locationStore.createIndex('name', 'name', { unique: false });
                        }
                        
                    if (!db.objectStoreNames.contains('inventory')) {
                            const inventoryStore = db.createObjectStore('inventory', { keyPath: 'id', autoIncrement: false });
                            inventoryStore.createIndex('productId', 'productId', { unique: false });
                            inventoryStore.createIndex('locationId', 'locationId', { unique: false });
                            inventoryStore.createIndex('product_location', ['productId', 'locationId'], { unique: true });
                        }
                        
                        if (!db.objectStoreNames.contains('transactions')) {
                            db.createObjectStore('transactions', { keyPath: 'timestamp' });
                        }
                        
                        // Add floor plans store
                        if (!db.objectStoreNames.contains('floorPlans')) {
                            db.createObjectStore('floorPlans', { keyPath: 'locationId' });
                        }
                        
                        // Add users store
                        if (!db.objectStoreNames.contains('users')) {
                            console.log('Creating users object store');
                            db.createObjectStore('users', { keyPath: 'id' });
                        }
                    }
                });
                
                console.log('IndexedDB initialized with idb module');
                return db;
            } catch (error) {
                console.error('Error initializing database:', error);
                throw error;
            }
        };

        const saveToIndexedDB = async (storeName, data) => {
            try {
                
                await db.clear(storeName);
                
                for (const item of data) {
                    await db.add(storeName, item);
                }
                
                console.log(`Data saved to ${storeName} successfully`);
            } catch (error) {
                console.error(`Error saving data to ${storeName}:`, error);
                throw error;
            }
        };

        const loadFromIndexedDB = async (storeName) => {
            try {
                const data = await db.getAll(storeName);
                return data;
                } catch (error) {
                console.error(`Error loading data from ${storeName}:`, error);
                throw error;
            }
        };

        const loadData = async () => {
            try {
                products = await loadFromIndexedDB('products') || [];
                locations = await loadFromIndexedDB('locations') || [];
                inventoryItems = await loadFromIndexedDB('inventory') || [];
                transactions = await loadFromIndexedDB('transactions') || [];
                
                // Try to load users, handle errors gracefully
                try {
                    users = await loadFromIndexedDB('users') || [];
                    console.log('Loaded users:', users);
                } catch (error) {
                    console.error('Error loading users:', error);
                    users = [];
                }
                
                // Set default location if empty
                if (locations.length === 0) {
                    locations = [{ id: '1', name: 'Location 1' }];
                    await saveToIndexedDB('locations', locations);
                }
                
                // Set default users if empty
                if (users.length === 0) {
                    users = [
                        { id: 'user-1', name: 'User 1' },
                        { id: 'user-2', name: 'User 2' }
                    ];
                    try {
                        await saveToIndexedDB('users', users);
                        console.log('Created default users:', users);
                    } catch (error) {
                        console.error('Error saving default users:', error);
                        // We'll continue with in-memory users even if saving fails
                    }
                }
                
                // Set current user
                if (users.length > 0) {
                    currentUser = users[0].name;
                    currentUserId = users[0].id;
                }
                
                // Add example product if no products exist
                if (products.length === 0) {
                    // Create example product
                    const exampleProduct = {
                        id: 'example-1',
                        name: 'Example Product',
                        price: 9.99,
                        comments: 'This is an example product to help you get started.',
                        barcode: '1234567890', // Example barcode
                    };
                    products.push(exampleProduct);
                    
                    // Add to inventory at default location
                    const exampleInventory = {
                        id: 'inv-example-1',
                        productId: exampleProduct.id,
                        locationId: locations[0].id,
                        quantity: 5
                    };
                    inventoryItems.push(exampleInventory);
                    
                    // Create initial transaction
                    const initialTransaction = {
                        type: 'add_inventory',
                        productId: exampleProduct.id,
                        productName: exampleProduct.name,
                        locationId: locations[0].id,
                        quantity: 5,
                        timestamp: new Date().toISOString()
                    };
                    transactions.push(initialTransaction);
                    
                    // Save the example data
                    await saveToIndexedDB('products', products);
                    await saveToIndexedDB('inventory', inventoryItems);
                    await saveToIndexedDB('transactions', transactions);
                    
                    console.log('Added example product to database');
                }
                
                // Set current location
                currentLocation = locations[0]?.id || '1';
                
                console.log('Data loaded:', {
                    products: products.length,
                    locations: locations.length,
                    inventory: inventoryItems.length,
                    transactions: transactions.length
                });
            } catch (error) {
                console.error('Error loading data:', error);
                // Set defaults
                products = [];
                locations = [{ id: '1', name: 'Location 1' }];
                inventoryItems = [];
                transactions = [];
                currentLocation = '1';
            }
        };

        // Initialize database and load data
        const initializeData = async () => {
            try {
                await initDB();
                console.log('IndexedDB initialized');
                await loadData();
                
                // Initialize users dropdown
                await loadUsers();

                // Update UI
                updateLocationSelect();
                updateTable();
                updateHistory();
            } catch (error) {
                console.error('Error initializing database:', error);
                alert('Error loading data. Using default values.');
                
                // Fallback to empty data
                products = [];
                locations = [{ id: '1', name: 'Location 1' }];
                inventoryItems = [];
                transactions = [];
                currentLocation = '1';
                
                // Update UI with default data
                updateLocationSelect();
                updateTable();
                updateHistory();
            }
        };

            
        async function save() {
            try {
                console.log('Saving data to IndexedDB:', {
                    products: products.length,
                    locations: locations.length,
                    inventory: inventoryItems.length,
                    transactions: transactions.length
                });
                
                // Save one store at a time to better isolate errors
                try {
                    await saveToIndexedDB('products', products);
                    console.log('Products saved successfully');
            } catch (error) {
                    console.error('Error saving products:', error);
                    alert(`Error saving products data: ${error.message || 'Unknown error'}`);
                    throw error;
                }
                
                try {
                    await saveToIndexedDB('locations', locations);
                    console.log('Locations saved successfully');
                } catch (error) {
                    console.error('Error saving locations:', error);
                    alert(`Error saving locations data: ${error.message || 'Unknown error'}`);
                    throw error;
                }
                
                try {
                    await saveToIndexedDB('inventory', inventoryItems);
                    console.log('Inventory saved successfully');
                } catch (error) {
                    console.error('Error saving inventory:', error);
                    alert(`Error saving inventory data: ${error.message || 'Unknown error'}`);
                    throw error;
                }
                
                try {
                    await saveToIndexedDB('transactions', transactions);
                    console.log('Transactions saved successfully');
                } catch (error) {
                    console.error('Error saving transactions:', error);
                    alert(`Error saving transactions data: ${error.message || 'Unknown error'}`);
                    throw error;
                }
                
                console.log('All data saved successfully');
            } catch (error) {
                console.error('Error in saveToLocalStorage:', error);
                alert('Error saving data. Please check console for details.');
            }
        }

        function updateLocationSelect() {
            const select = document.getElementById('locationSelect');
            select.innerHTML = '';
            
            locations.forEach(location => {
                const option = document.createElement('option');
                option.value = location.id;
                option.textContent = location.name;
                if (location.id === currentLocation) {
                    option.selected = true;
                }
                select.appendChild(option);
            });

            // If no location is selected, select the first one
            if (!currentLocation && locations.length > 0) {
                currentLocation = locations[0].id;
                select.value = currentLocation;
            }
        }

        function changeLocation(selectedLocationId) {
            if (!selectedLocationId && locations.length > 0) {
                // If somehow no location is selected, select the first one
                selectedLocationId = locations[0].id;
                document.getElementById('locationSelect').value = selectedLocationId;
            }
            currentLocation = selectedLocationId;
            updateTable();
        }

        async function renameLocation() {
            const newName = document.getElementById('locationName').value.trim();
            if (!newName) {
                alert('Location name cannot be empty');
                const currentLoc = locations.find(loc => loc.id === currentLocation);
                document.getElementById('locationName').value = currentLoc ? currentLoc.name : '';
                return;
            }

            const locationIndex = locations.findIndex(loc => loc.id === currentLocation);
            if (locationIndex !== -1) {
                const oldName = locations[locationIndex].name;
                locations[locationIndex].name = newName;
            
            await addToHistory({
                type: 'rename_location',
                    locationId: currentLocation,
                oldName: oldName,
                newName: newName,
                timestamp: new Date().toISOString()
            });

                await save();
            updateLocationSelect();
            }
        }

        async function addLocation() {
            const newLocationId = String(Date.now());
            const newLocation = {
                id: newLocationId,
                name: `Location ${locations.length + 1}`
            };
            
            locations.push(newLocation);
            currentLocation = newLocationId;
            
            await addToHistory({
                type: 'add_location',
                location: newLocation,
                timestamp: new Date().toISOString()
            });
            
            await save();
            updateLocationSelect();
            updateTable();
        }

        async function deleteLocation() {
            if (locations.length <= 1) {
                alert('Cannot delete the last location');
                return;
            }
            
            if (confirm('Are you sure you want to delete this location? All inventory items in this location will be deleted.')) {
                // Remove inventory items for this location
                inventoryItems = inventoryItems.filter(item => item.locationId !== currentLocation);
                
                // Remove the location
                const locationIndex = locations.findIndex(loc => loc.id === currentLocation);
                const deletedLocation = locations[locationIndex];
                locations.splice(locationIndex, 1);
                
                // Update current location to first available
                currentLocation = locations[0].id;
                
                await addToHistory({
                    type: 'delete_location',
                    location: deletedLocation,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateLocationSelect();
                updateTable();
            }
        }

        async function addItem() {
            const name = document.getElementById('itemName').value.trim();
            const quantity = parseInt(document.getElementById('itemQuantity').value);
            const price = parseFloat(document.getElementById('itemPrice').value);

            if (!name || isNaN(quantity) || isNaN(price) || quantity < 0 || price < 0) {
                alert('Please fill all fields with valid values');
                return;
            }

            // Create product if it doesn't exist
            let product = products.find(p => p.name.toLowerCase() === name.toLowerCase());
            
            if (!product) {
                product = { 
                    id: Date.now().toString(),
                    name, 
                    price,
                    comments: '',
                    barcode: '', 
                };
                products.push(product);
            }
            
            // Check if inventory entry exists
            let inventoryEntry = inventoryItems.find(item => 
                item.productId === product.id && item.locationId === currentLocation
            );
            
            if (inventoryEntry) {
                // Update existing inventory
                const oldQuantity = inventoryEntry.quantity;
                inventoryEntry.quantity += quantity;
                
            await addToHistory({
                    type: 'update_quantity',
                    productId: product.id,
                    productName: product.name,
                    locationId: currentLocation,
                    oldQuantity,
                    newQuantity: inventoryEntry.quantity,
                timestamp: new Date().toISOString()
            });
            } else {
                // Create new inventory entry
                inventoryEntry = {
                    id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                    productId: product.id,
                    locationId: currentLocation,
                    quantity
                };
                
                inventoryItems.push(inventoryEntry);
                
                await addToHistory({
                    type: 'add_inventory',
                    productId: product.id,
                    productName: product.name,
                    locationId: currentLocation,
                    quantity,
                    timestamp: new Date().toISOString()
                });
            }

            await save();
            updateTable();
            clearForm();
        }

        async function deleteItem(productId) {
            const product = products.find(p => p.id === productId);
            if (!product) return;
            
            if (confirm(`Are you sure you want to delete "${product.name}" from all locations?`)) {
                // Get all inventory entries for this product
                const affectedEntries = inventoryItems.filter(item => item.productId === productId);
                
                // Record each deletion in history
                for (const entry of affectedEntries) {
                    const locationName = locations.find(loc => loc.id === entry.locationId)?.name || 'Unknown';
                    
                await addToHistory({
                        type: 'delete_inventory',
                        productId,
                        productName: product.name,
                        locationId: entry.locationId,
                        locationName,
                        quantity: entry.quantity,
                    timestamp: new Date().toISOString()
                });
                }
                
                // Remove all inventory entries for this product
                inventoryItems = inventoryItems.filter(item => item.productId !== productId);
                
                // Remove the product completely
                products = products.filter(p => p.id !== productId);
                
                await addToHistory({
                    type: 'delete_product',
                    productId,
                    productName: product.name,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateTable();
            }
        }

        async function editField(productId, field, element) {
            const product = products.find(p => p.id === productId);
            if (!product) return;

            const currentValue = element.textContent;
            const input = document.createElement('input');
            input.type = field === 'price' ? 'number' : field === 'quantity' ? 'number' : 'text';
            input.step = field === 'price' ? '0.01' : '1';
            input.min = field === 'quantity' || field === 'price' ? '0' : '';
            input.value = currentValue;
            input.className = 'editable editing';
            
            element.textContent = '';
            element.appendChild(input);
            input.focus();

            async function saveEdit() {
                const newValue = input.value;
                if (newValue === currentValue) {
                    element.textContent = currentValue;
                    return;
                }
                
                if (field === 'price') {
                    const newPrice = parseFloat(newValue);
                    if (!isNaN(newPrice) && newPrice >= 0) {
                        const oldPrice = product.price;
                        product.price = newPrice;
                        
                        await addToHistory({
                            type: 'edit_product',
                            productId: product.id,
                            productName: product.name,
                            field: 'price',
                            oldValue: oldPrice,
                            newValue: newPrice,
                            timestamp: new Date().toISOString()
                        });
                        
                        await save();
                        updateTable();
                    } else {
                        element.textContent = currentValue;
                        return;
                    }
                } else if (field === 'name') {
                    const newName = newValue.trim();
                    if (newName) {
                        const oldName = product.name;
                        product.name = newName;
                        
                        await addToHistory({
                            type: 'edit_product',
                            productId: product.id,
                            productName: newName,
                            field: 'name',
                            oldValue: oldName,
                            newValue: newName,
                            timestamp: new Date().toISOString()
                        });
                        
                        await save();
                        updateTable();
                    } else {
                        element.textContent = currentValue;
                        return;
                    }
                } else if (field === 'quantity') {
                    const newQuantity = parseInt(newValue);
                    if (!isNaN(newQuantity) && newQuantity >= 0) {
                        // Find inventory entry for this product and location
                        let inventoryEntry = inventoryItems.find(item => 
                            item.productId === productId && item.locationId === currentLocation
                        );
                        
                        if (inventoryEntry) {
                            const oldQuantity = inventoryEntry.quantity;
                            inventoryEntry.quantity = newQuantity;
                            
                            await addToHistory({
                                type: 'update_quantity',
                                productId: product.id,
                                productName: product.name,
                                locationId: currentLocation,
                                oldQuantity,
                                newQuantity,
                                timestamp: new Date().toISOString()
                            });
                        } else if (newQuantity > 0) {
                            // Create new inventory entry
                            inventoryEntry = {
                                id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                                productId: product.id,
                                locationId: currentLocation,
                                quantity: newQuantity
                            };
                            
                            inventoryItems.push(inventoryEntry);
                            
                            await addToHistory({
                                type: 'add_inventory',
                                productId: product.id,
                                productName: product.name,
                                locationId: currentLocation,
                                quantity: newQuantity,
                                timestamp: new Date().toISOString()
                            });
                        }
                        
                        await save();
                        updateTable();
                    } else {
                        element.textContent = currentValue;
                        return;
                    }
                }
            }

            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                    input.blur();
                }
            });
        }

        function toggleDetails(id) {
            const details = document.getElementById(`details-${id}`);
            const button = event.target;
            if (details.classList.contains('show')) {
                details.classList.remove('show');
                button.textContent = '‚ñº';
            } else {
                details.classList.add('show');
                button.textContent = '‚ñ≤';
            }
        }

        async function updateComments(productId) {
            const product = products.find(p => p.id === productId);
            if (!product) return;

            const newComments = document.getElementById(`comments-${productId}`).value;
            
            if (product.comments !== newComments) {
                const oldComments = product.comments || '';
                product.comments = newComments;

                await addToHistory({
                    type: 'update_comments',
                    productId: product.id,
                    productName: product.name,
                    oldValue: oldComments,
                    newValue: newComments,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateTable();
            }
        }

        async function changeQuantity(productId, change) {
            const product = products.find(item => item.id === productId);
            if (!product) return;
            
            // Find inventory entry for this product and location
            let inventoryEntry = inventoryItems.find(item => 
                item.productId === productId && item.locationId === currentLocation
            );
            
            if (inventoryEntry) {
                // Update existing entry
                const oldQuantity = inventoryEntry.quantity;
                const newQuantity = oldQuantity + change;
                
                if (newQuantity >= 0) {
                    inventoryEntry.quantity = newQuantity;
                    
                    await addToHistory({
                        type: 'update_quantity',
                        productId: product.id,
                        productName: product.name,
                        locationId: currentLocation,
                        oldQuantity,
                        newQuantity,
                        timestamp: new Date().toISOString()
                    });
                    
                    await save();
                    updateTable();
                }
            } else if (change > 0) {
                // Create new inventory entry
                inventoryEntry = {
                    id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                    productId: product.id,
                    locationId: currentLocation,
                    quantity: change
                };
                
                inventoryItems.push(inventoryEntry);
                
                await addToHistory({
                    type: 'add_inventory',
                    productId: product.id,
                    productName: product.name,
                    locationId: currentLocation,
                    quantity: change,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateTable();
            }
        }

        // Allow direct editing of location quantity by clicking on the value
        async function editLocationQuantity(productId, locationId, element) {
            const product = products.find(p => p.id === productId);
            if (!product) return;

            const currentValue = element.textContent;
            const input = document.createElement('input');
            input.type = 'number';
            input.step = '1';
            input.min = '0';
            input.value = currentValue;
            input.className = 'quantity-value editing';
            input.style.width = '40px';
            
            element.textContent = '';
            element.appendChild(input);
            input.focus();

            async function saveEdit() {
                const newValue = parseInt(input.value);
                const oldValue = parseInt(currentValue);
                
                if (isNaN(newValue) || newValue === oldValue) {
                    element.textContent = currentValue;
                    return;
                }
                
                if (newValue >= 0) {
                    // Find inventory entry for this product and location
                    let inventoryEntry = inventoryItems.find(item => 
                        item.productId === productId && item.locationId === locationId
                    );
                    
                    if (inventoryEntry) {
                        inventoryEntry.quantity = newValue;
                        
                        await addToHistory({
                            type: 'update_quantity',
                            productId: product.id,
                            productName: product.name,
                            locationId: locationId,
                            oldQuantity: oldValue,
                            newQuantity: newValue,
                            timestamp: new Date().toISOString()
                        });
                    } else if (newValue > 0) {
                        // Create new inventory entry
                        inventoryEntry = {
                            id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                            productId: product.id,
                            locationId: locationId,
                            quantity: newValue
                        };
                        
                        inventoryItems.push(inventoryEntry);
                        
                        await addToHistory({
                            type: 'add_inventory',
                            productId: product.id,
                            productName: product.name,
                            locationId: locationId,
                            quantity: newValue,
                            timestamp: new Date().toISOString()
                        });
                    }
                    
                    await save();
                    updateTable();
                } else {
                    element.textContent = currentValue;
                }
            }

            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                    input.blur();
                }
            });
        }

        // Debounce function to limit how often a function can be called
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        }
        
        // Store pending changes to show immediate visual feedback
        const pendingQuantityChanges = {};
        
        // Apply visual update immediately without saving
        function applyVisualQuantityChange(productId, locationId, change) {
            const key = `${productId}-${locationId}`;
            pendingQuantityChanges[key] = (pendingQuantityChanges[key] || 0) + change;
            
            // Find the quantity display element and update it
            const quantityElement = document.querySelector(`[data-product-id="${productId}"][data-location-id="${locationId}"]`);
            if (quantityElement) {
                const currentQuantity = parseInt(quantityElement.textContent || '0');
                const newQuantity = Math.max(0, currentQuantity + change);
                quantityElement.textContent = newQuantity;
            }
            
            // Update total if needed
            const totalElement = document.querySelector(`[data-product-id="${productId}"][data-total="true"]`);
            if (totalElement) {
                const currentTotal = parseInt(totalElement.textContent.replace('Total: ', '') || '0');
                const newTotal = Math.max(0, currentTotal + change);
                totalElement.textContent = `Total: ${newTotal}`;
            }
        }

        // Debounced function to actually save changes
        const saveQuantityChange = debounce(async (productId, locationId, change) => {
            const key = `${productId}-${locationId}`;
            const totalChange = pendingQuantityChanges[key] || 0;
            
            // Reset pending changes
            pendingQuantityChanges[key] = 0;
            
            if (totalChange === 0) return;
            
            const product = products.find(item => item.id === productId);
            if (!product) return;
            
            // Find inventory entry for this product and the specified location
            let inventoryEntry = inventoryItems.find(item => 
                item.productId === productId && item.locationId === locationId
            );
            
            if (inventoryEntry) {
                // Update existing entry
                const oldQuantity = inventoryEntry.quantity;
                const newQuantity = Math.max(0, oldQuantity + totalChange);
                
                inventoryEntry.quantity = newQuantity;
                
                await addToHistory({
                    type: 'update_quantity',
                    productId: product.id,
                    productName: product.name,
                    locationId: locationId,
                    oldQuantity,
                    newQuantity,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateTable();
            } else if (totalChange > 0) {
                // Create new inventory entry
                inventoryEntry = {
                    id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                    productId: product.id,
                    locationId: locationId,
                    quantity: totalChange
                };
                
                inventoryItems.push(inventoryEntry);
                
                await addToHistory({
                    type: 'add_inventory',
                    productId: product.id,
                    productName: product.name,
                    locationId: locationId,
                    quantity: totalChange,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateTable();
            }
        }, 500); // 500ms debounce time
        
        // Function to change quantity with debounce
        function changeSpecificLocationQuantityWithDebounce(productId, locationId, change) {
            // Apply visual change immediately
            applyVisualQuantityChange(productId, locationId, change);
            
            // Schedule the actual save after debounce
            saveQuantityChange(productId, locationId, change);
        }

        function clearForm() {
            document.getElementById('itemName').value = '';
            document.getElementById('itemQuantity').value = '';
            document.getElementById('itemPrice').value = '';
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${day}-${month}-${year} ${hours}:${minutes}`;
        }

        function updateHistory() {
            const historyList = document.getElementById('historyList');
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            historyList.innerHTML = '';
            
            if (!Array.isArray(transactions)) {
                console.warn('Transactions is not an array:', transactions);
                return;
            }
            
            // Sort transactions by timestamp (newest first)
            const sortedTransactions = [...transactions].sort((a, b) => 
                new Date(b.timestamp) - new Date(a.timestamp)
            );
            
            // Filter transactions if search term is provided
            const filteredTransactions = searchTerm ? 
                sortedTransactions.filter(transaction => 
                    (transaction.productName && transaction.productName.toLowerCase().includes(searchTerm)) || 
                    (transaction.productId && products.some(p => 
                        p.id === transaction.productId && 
                        p.name.toLowerCase().includes(searchTerm)
                    ))
                ) : 
                sortedTransactions;
            
            filteredTransactions.forEach((transaction, index) => {
                const div = document.createElement('div');
                div.className = 'history-item';
                let changeText = '';
                
                try {
                    // Get location name if locationId exists
                    const getLocationName = (locationId) => {
                        const location = locations.find(loc => loc.id === locationId);
                        return location ? location.name : 'Unknown Location';
                    };
                    
                    switch (transaction.type) {
                        case 'add_inventory':
                            changeText = `[${transaction.user}] Added ${transaction.quantity} ${transaction.productName} to ${getLocationName(transaction.locationId)}`;
                            break;
                        case 'delete_inventory':
                            const locationDisplayName = transaction.locationName || getLocationName(transaction.locationId);
                            changeText = `[${transaction.user}] Deleted ${transaction.productName} from ${locationDisplayName}`;
                            break;
                        case 'delete_product':
                            changeText = `[${transaction.user}] Removed product ${transaction.productName} completely`;
                            break;
                        case 'update_quantity':
                            changeText = `[${transaction.user}] Changed quantity of ${transaction.productName} from ${transaction.oldQuantity} to ${transaction.newQuantity} in ${getLocationName(transaction.locationId)}`;
                            break;
                        case 'edit_product':
                            changeText = `[${transaction.user}] Changed ${transaction.field} of ${transaction.productName} from ${transaction.oldValue} to ${transaction.newValue}`;
                            break;
                        case 'update_details':
                            changeText = `[${transaction.user}] Updated details for ${transaction.productName}`;
                            break;
                        case 'add_location':
                            changeText = `[${transaction.user}] Added new location: ${transaction.location.name}`;
                            break;
                        case 'delete_location':
                            changeText = `[${transaction.user}] Deleted location: ${transaction.location.name}`;
                            break;
                        case 'rename_location':
                            changeText = `[${transaction.user}] Renamed ${transaction.oldName} to ${transaction.newName}`;
                            break;
                        case 'update_comments':
                            changeText = `[${transaction.user}] Updated comments for ${transaction.productName}`;
                            break;
                        default:
                            changeText = `[${transaction.user}] Unknown transaction type: ${transaction.type}`;
                    }
                } catch (error) {
                    console.error('Error processing transaction entry:', error, transaction);
                    changeText = 'Error: Invalid transaction entry';
                }

                div.innerHTML = `
                    <span>${changeText} - ${formatDate(transaction.timestamp)}</span>
                `;
                historyList.appendChild(div);
            });
            
            // Show a message if no matching transactions
            if (searchTerm && filteredTransactions.length === 0) {
                const noResults = document.createElement('div');
                noResults.className = 'no-results';
                noResults.textContent = 'No matching history items found.';
                historyList.appendChild(noResults);
            }
        }

        async function addToHistory(change) {
            // Add user information to the change record
            change.user = currentUser;
            change.userId = currentUserId;
            transactions.push(change);
            await save();
            updateHistory();
        }

        document.getElementById('searchInput').addEventListener('input', function() {
            updateTable();
            updateHistory(); // Also update history when search input changes
        });

        // Initial load
        updateLocationSelect();
        updateTable();
        updateHistory();

        function updateTable() {
            const tbody = document.getElementById('inventoryBody');
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            
            tbody.innerHTML = '';
            
            // Get products with inventory in any location (for total quantities)
            const productInventory = {};
            
            // Initialize with all products
            products.forEach(product => {
                productInventory[product.id] = {
                    product,
                        quantities: {},
                    totalQuantity: 0
                };
            });
            
            // Add quantities from inventory
            inventoryItems.forEach(item => {
                if (productInventory[item.productId]) {
                    productInventory[item.productId].quantities[item.locationId] = item.quantity;
                    productInventory[item.productId].totalQuantity += item.quantity;
                }
            });
            
            // Filter by search term
            const filteredProducts = Object.values(productInventory).filter(entry => {
                const product = entry.product;
                const matchesName = product.name.toLowerCase().includes(searchTerm);
                const matchesBarcode = product.barcode && product.barcode.toLowerCase().includes(searchTerm);
                return matchesName || matchesBarcode;
            });
            
            // Sort by name
            filteredProducts.sort((a, b) => a.product.name.localeCompare(b.product.name));
            
            // Display the products
            filteredProducts.forEach(entry => {
                const product = entry.product;
                const currentLocationQuantity = entry.quantities[currentLocation] || 0;
                
                const tr = document.createElement('tr');
                tr.className = 'item-row';
                tr.dataset.productId = product.id;
                
                const locationQuantities = locations.map(loc => {
                    const quantity = entry.quantities[loc.id] || 0;
                    const isCurrent = loc.id === currentLocation;
                    return quantity > 0 ? 
                        `<span class="location-quantity ${isCurrent ? 'current' : ''}">${loc.name}: ${quantity}</span>` : 
                        '';
                }).filter(Boolean).join('');

                const detailsHtml = `
                    <div class="item-details" id="details-${product.id}">
                        <div class="item-details-grid">
                            <div class="item-details-section">
                                <label>Comments:</label>
                                <textarea id="comments-${product.id}" onblur="updateComments('${product.id}')">${product.comments || ''}</textarea>
                            </div>
                        </div>
                    </div>
                `;

                tr.innerHTML = `
                    <td>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span class="editable" onclick="editField('${product.id}', 'name', this)">${product.name}</span>
                            <button class="toggle-details-btn" onclick="toggleDetails('${product.id}')">‚ñº</button>
                        </div>
                    </td>
                    <td>
                        <div class="total-quantity">
                            <strong data-product-id="${product.id}" data-total="true">Total: ${entry.totalQuantity}</strong>
                        </div>
                        <div class="location-quantities-list">
                            ${locations.map(loc => {
                                const locQuantity = entry.quantities[loc.id] || 0;
                                const isCurrent = loc.id === currentLocation;
                                return `
                                <div class="location-quantity-item ${isCurrent ? 'current' : ''}">
                                    <span class="location-name">${loc.name}:</span>
                                    <div class="quantity-controls">
                                        <button onclick="changeSpecificLocationQuantityWithDebounce('${product.id}', '${loc.id}', -1)" class="quantity-btn">-</button>
                                        <span class="quantity-value" data-product-id="${product.id}" data-location-id="${loc.id}" onclick="editLocationQuantity('${product.id}', '${loc.id}', this)">${locQuantity}</span>
                                        <button onclick="changeSpecificLocationQuantityWithDebounce('${product.id}', '${loc.id}', 1)" class="quantity-btn">+</button>
                                    </div>
                                </div>
                                `;
                            }).join('')}
                        </div>
                    </td>
                    <td>
                        <span class="editable" onclick="editField('${product.id}', 'price', this)">${product.price.toFixed(2)}</span>
                    </td>
                    <td>
                        <button onclick="deleteItem('${product.id}')">Delete</button>
                        <button class="barcode-btn" onclick="openBarcodeModal('${product.id}')">${product.barcode ? 'Edit Barcode' : 'Add Barcode'}</button>
                    </td>
                `;
                tbody.appendChild(tr);

                // Add details row
                const detailsRow = document.createElement('tr');
                detailsRow.className = 'item-details-row';
                detailsRow.innerHTML = `
                    <td colspan="4">
                        ${detailsHtml}
                    </td>
                `;
                tbody.appendChild(detailsRow);
            });
        }

        // Handle errors with IndexedDB
        const handleDBError = (error) => {
            console.error('IndexedDB error:', error.message);
            alert(`Database error: ${error.message}. Some features may not work correctly.`);
        };

        // Add global event handler for IndexedDB errors
        window.addEventListener('error', (event) => {
            if (event.target && event.target.error && event.target.error.name && 
                event.target.error.name.includes('IDB')) {
                handleDBError(event.target.error);
            }
        });

        // Initialize the app when DOM content is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize with error handling
            initializeData().catch(error => {
                console.error('Error during initialization:', error);
                alert('Failed to initialize the application. Please refresh the page or check console for details.');
            });
        });

        // Floor Plan functionality
        let currentTool = 'select';
        let shapes = [];
        let selectedShape = null;
        let isDrawing = false;
        let startX, startY;
        let placedProducts = [];
        let isDragging = false;
        let draggedElement = null;
        let dragOffsetX, dragOffsetY;
        let canvas, ctx;
        let isEditMode = true;

        // Konva objects
        let stage;
        let layer;
        let transformer;
        let konvaShapes = [];

        function openFloorPlan() {
            const modal = document.getElementById('floorPlanModal');
            modal.style.display = 'block';
            
            // Set location name
            const locationName = locations.find(loc => loc.id === currentLocation)?.name || 'Unknown Location';
            document.getElementById('floorPlanLocationName').textContent = locationName;
            
            // Reset state
            selectedShape = null;
            isDrawing = false;
            
            // Always start in select mode
            currentTool = 'select';
            
            // Update UI to show select as active
            document.querySelectorAll('.shape-button').forEach(button => {
                if (button.dataset.tool === 'select') {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                    button.classList.remove('delete-tool');
                }
            });
            
            // Initialize Konva stage
            initKonvaStage();
            
            // Load existing floor plan data
            loadFloorPlan(currentLocation);
            
            // Load products for placement
            loadProductsForPlacement();
            
            console.log('Floor plan opened, stage initialized');
        }

        function initKonvaStage() {
            // Check if stage already exists
            if (stage) {
                stage.destroy();
            }
            
            // Create Konva stage with the correct container ID
            stage = new Konva.Stage({
                container: 'floorPlanCanvas',
                width: 1000,
                height: 600
            });
            
            // Create layer for all shapes
            layer = new Konva.Layer();
            stage.add(layer);
            
            // Create transformer for shape manipulation
            transformer = new Konva.Transformer({
                nodes: [],
                enabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right'],
                rotateEnabled: true,
                borderDash: [3, 3]
            });
            layer.add(transformer);
            
            // Ensure the layer is drawn
            layer.draw();
            
            // Set up event listeners
            setupKonvaEvents();
            
            console.log("Konva stage initialized with container:", stage.container());
        }
        
        function setupKonvaEvents() {
            // Clear any existing event listeners
            stage.off('click');
            stage.off('mousedown');
            stage.off('mousemove');
            stage.off('mouseup');
            
            // Stage click handler for selection
            stage.on('click', function(e) {
                // Log the click for debugging
                console.log("Stage clicked", e.target, "current tool:", currentTool);
                
                // If clicked on empty stage
                if (e.target === stage) {
                    transformer.nodes([]);
                    selectedShape = null;
                    layer.draw();
                    return;
                }
                
                // Handle delete tool
                if (currentTool === 'delete') {
                    try {
                        const clickedShape = e.target;
                        console.log("Attempting to delete shape:", clickedShape);
                        
                        // Remove from transformer
                        transformer.nodes([]);
                        
                        // If it's a basic shape, remove from konvaShapes
                        const shapeIndex = konvaShapes.indexOf(clickedShape);
                        if (shapeIndex > -1) {
                            konvaShapes.splice(shapeIndex, 1);
                        }
                        
                        // If it's a group with a product ID, remove from placedProducts
                        if (clickedShape instanceof Konva.Group && clickedShape.attrs.productId) {
                            const productId = clickedShape.attrs.productId;
                            placedProducts = placedProducts.filter(p => p.productId !== productId);
                        }
                        
                        // Delete the shape
                        clickedShape.destroy();
                        selectedShape = null;
                        layer.draw();
                        
                        console.log("Shape deleted with delete tool, staying in delete mode");
                        
                        // No need to switch tools - stay in delete mode
                        return;
                    } catch (error) {
                        console.error("Error deleting shape with delete tool:", error);
                    }
                }
                
                if (currentTool === 'select') {
                    // Don't select when clicking on transformer
                    if (e.target.getParent() && e.target.getParent().className === 'Transformer') {
                        return;
                    }
                    
                    // Select the shape
                    try {
                        console.log("Selecting shape:", e.target);
                        transformer.nodes([e.target]);
                        selectedShape = e.target;
                        layer.draw();
                    } catch (error) {
                        console.error("Error selecting shape:", error);
                        // Reset transformer if there's an error
                        transformer.nodes([]);
                        selectedShape = null;
                        layer.draw();
                    }
                }
            });
            
            // Handle drawing new shapes
            stage.on('mousedown', function(e) {
                console.log("Mouse down, current tool:", currentTool, "isEditMode:", isEditMode);
                
                if (currentTool === 'select' || !isEditMode) return;
                
                isDrawing = true;
                const pos = stage.getPointerPosition();
                startX = pos.x;
                startY = pos.y;
                
                try {
                    if (currentTool === 'rectangle') {
                        console.log("Creating rectangle at", startX, startY);
                        // Create new rectangle
                        selectedShape = new Konva.Rect({
                            x: startX,
                            y: startY,
                            width: 0,
                            height: 0,
                            fill: document.getElementById('shapeColor').value,
                            stroke: '#000',
                            strokeWidth: 1,
                            draggable: true
                        });
                        
                        // Add drag handlers to prevent transformer issues
                        addDragHandlersToShape(selectedShape);
                        
                        layer.add(selectedShape);
                        konvaShapes.push(selectedShape);
                        layer.draw();
                        
                    } else if (currentTool === 'circle') {
                        // Create new circle
                        selectedShape = new Konva.Circle({
                            x: startX,
                            y: startY,
                            radius: 0,
                            fill: document.getElementById('shapeColor').value,
                            stroke: '#000',
                            strokeWidth: 1,
                            draggable: true
                        });
                        
                        // Add drag handlers to prevent transformer issues
                        addDragHandlersToShape(selectedShape);
                        
                        layer.add(selectedShape);
                        konvaShapes.push(selectedShape);
                        layer.draw();
                        
                    } else if (currentTool === 'text') {
                        // Create new text
                        const textContent = prompt("Enter text:", "Text");
                        if (textContent) {
                            selectedShape = new Konva.Text({
                                x: startX,
                                y: startY,
                                text: textContent,
                                fontSize: 20,
                                fill: document.getElementById('shapeColor').value,
                                draggable: true
                            });
                            
                            // Add drag handlers to prevent transformer issues
                            addDragHandlersToShape(selectedShape);
                            
                            layer.add(selectedShape);
                            konvaShapes.push(selectedShape);
                            
                            // Select the new text
                            transformer.nodes([selectedShape]);
                            
                            // Switch to select tool immediately after placing text
                            setTimeout(function() {
                                selectTool('select');
                            }, 10);
                            
                            layer.draw();
                        }
                        isDrawing = false;
                    }
                } catch (error) {
                    console.error("Error creating shape:", error);
                    isDrawing = false;
                    selectedShape = null;
                }
            });
            
            // Handle mouse move for drawing
            stage.on('mousemove', function(e) {
                if (!isDrawing || !selectedShape) return;
                
                const pos = stage.getPointerPosition();
                
                try {
                    if (currentTool === 'rectangle' && selectedShape instanceof Konva.Rect) {
                        const width = pos.x - startX;
                        const height = pos.y - startY;
                        
                        selectedShape.width(width);
                        selectedShape.height(height);
                        layer.batchDraw();
                        
                    } else if (currentTool === 'circle' && selectedShape instanceof Konva.Circle) {
                        const dx = pos.x - startX;
                        const dy = pos.y - startY;
                        const radius = Math.sqrt(dx * dx + dy * dy);
                        
                        selectedShape.radius(radius);
                        layer.batchDraw();
                    }
                } catch (error) {
                    console.error("Error updating shape:", error);
                    isDrawing = false;
                }
            });
            
            // Handle mouse up for finishing drawing
            stage.on('mouseup', function() {
                console.log("Mouse up detected, isDrawing:", isDrawing, "currentTool:", currentTool);
                
                // Only handle shape completion if we're in drawing mode
                if (!isDrawing) return;
                
                // Reset drawing state first
                isDrawing = false;
                
                // Handle completed shape
                if (selectedShape) {
                    try {
                        // Check if we should keep the shape based on its size
                        let shouldKeepShape = true;
                        
                        if (selectedShape instanceof Konva.Rect && 
                            (Math.abs(selectedShape.width()) < 5 || Math.abs(selectedShape.height()) < 5)) {
                            shouldKeepShape = false;
                        } else if (selectedShape instanceof Konva.Circle && selectedShape.radius() < 5) {
                            shouldKeepShape = false;
                        }
                        
                        if (!shouldKeepShape) {
                            // Remove shapes that are too small
                            selectedShape.remove();
                            const index = konvaShapes.indexOf(selectedShape);
                            if (index > -1) {
                                konvaShapes.splice(index, 1);
                            }
                            selectedShape = null;
                        } else {
                            // Select the shape we just drew
                            transformer.nodes([selectedShape]);
                        }
                        
                        // Switch to select tool only if we were using a drawing tool
                        // This ensures delete tool stays active
                        if (['rectangle', 'circle', 'text'].includes(currentTool)) {
                            setTimeout(function() {
                                selectTool('select');
                            }, 10);
                        }
                        
                        layer.draw();
                    } catch (error) {
                        console.error("Error finalizing shape:", error);
                        // Reset state on error
                        selectedShape = null;
                        selectTool('select');
                        layer.draw();
                    }
                } else {
                    // Even if there's no selected shape, still switch to select tool if using drawing tools
                    if (['rectangle', 'circle', 'text'].includes(currentTool)) {
                        selectTool('select');
                    }
                }
            });
            
            console.log("Konva event handlers set up");
        }

        // Helper function to add consistent drag handlers to all shapes
        function addDragHandlersToShape(shape) {
            // Clear any existing handlers to prevent duplicates
            shape.off('dragstart');
            shape.off('dragend');
            
            shape.on('dragstart', function() {
                console.log('Drag started on shape', shape);
                // Remove the transformer during drag to prevent errors
                transformer.nodes([]);
            });
            
            shape.on('dragend', function() {
                console.log('Drag ended on shape', shape, 'current tool:', currentTool);
                // Only add the transformer back if still in select mode
                if (currentTool === 'select') {
                    transformer.nodes([shape]);
                    selectedShape = shape;
                    layer.draw();
                }
            });
            
            // Make sure the shape is clickable
            shape.listening(true);
        }

        function closeFloorPlan() {
            const modal = document.getElementById('floorPlanModal');
            modal.style.display = 'none';
        }

        async function loadFloorPlan(locationId) {
            try {
                console.log('Loading floor plan for location:', locationId);
                
                // Load floor plan data from IndexedDB
                const floorPlan = await db.get('floorPlans', locationId);
                
                if (floorPlan) {
                    console.log('Floor plan data loaded:', floorPlan);
                    shapes = floorPlan.shapes || [];
                    placedProducts = floorPlan.placedProducts || [];
                    
                    // Clear Konva shapes
                    konvaShapes = [];
                    layer.destroyChildren();
                    
                    // Add transformer back
                    layer.add(transformer);
                    
                    // Create Konva shapes from saved data
                    shapes.forEach(shape => {
                        let konvaShape;
                        
                        if (shape.type === 'rectangle') {
                            konvaShape = new Konva.Rect({
                                x: shape.x,
                                y: shape.y,
                                width: shape.width,
                                height: shape.height,
                                fill: shape.fill,
                                stroke: '#000',
                                strokeWidth: 1,
                                draggable: true
                            });
                        } else if (shape.type === 'circle') {
                            konvaShape = new Konva.Circle({
                                x: shape.x,
                                y: shape.y,
                                radius: shape.radius,
                                fill: shape.fill,
                                stroke: '#000',
                                strokeWidth: 1,
                                draggable: true
                            });
                        } else if (shape.type === 'text') {
                            konvaShape = new Konva.Text({
                                x: shape.x,
                                y: shape.y,
                                text: shape.text,
                                fontSize: 20,
                                fill: shape.fill,
                                draggable: true
                            });
                        }
                        
                        if (konvaShape) {
                            layer.add(konvaShape);
                            konvaShapes.push(konvaShape);
                        }
                    });
                    
                    // Add placed products
                    const placedProductsContainer = document.getElementById('placedProducts');
                    placedProductsContainer.innerHTML = '';
                    
                    placedProducts.forEach(product => {
                        const productText = new Konva.Text({
                            x: product.x,
                            y: product.y,
                            text: product.name,
                            fontSize: 14,
                            padding: 5,
                            fill: '#ffffff',
                            draggable: true,
                            id: 'product-' + product.productId
                        });
                        
                        const productBox = new Konva.Rect({
                            x: product.x,
                            y: product.y,
                            width: productText.width(),
                            height: productText.height(),
                            fill: '#2196F3',
                            opacity: 0.7,
                            cornerRadius: 3,
                            draggable: true
                        });
                        
                        // Group product text and box
                        const productGroup = new Konva.Group({
                            draggable: true,
                            productId: product.productId
                        });
                        
                        productGroup.add(productBox);
                        productGroup.add(productText);
                        layer.add(productGroup);
                    });
                    
                    layer.draw();
                } else {
                    console.log('No floor plan found for location:', locationId);
                    // Create empty floor plan
                    shapes = [];
                    placedProducts = [];
                    layer.draw();
                }
            } catch (error) {
                console.error('Error loading floor plan:', error);
                alert('Error loading floor plan: ' + error.message);
                shapes = [];
                placedProducts = [];
                layer.draw();
            }
        }

        async function saveFloorPlan() {
            try {
                // Export Konva shapes to simple objects
                shapes = konvaShapes.map(shape => {
                    const baseShape = {
                        x: shape.x(),
                        y: shape.y(),
                        fill: shape.fill()
                    };
                    
                    if (shape instanceof Konva.Rect) {
                        return {
                            ...baseShape,
                            type: 'rectangle',
                            width: shape.width(),
                            height: shape.height()
                        };
                    } else if (shape instanceof Konva.Circle) {
                        return {
                            ...baseShape,
                            type: 'circle',
                            radius: shape.radius()
                        };
                    } else if (shape instanceof Konva.Text) {
                        return {
                            ...baseShape,
                            type: 'text',
                            text: shape.text()
                        };
                    }
                    
                    return null;
                }).filter(Boolean);
                
                // Get product groups and export their data
                placedProducts = [];
                layer.find('.Group').forEach(group => {
                    if (group.attrs.productId) {
                        placedProducts.push({
                            productId: group.attrs.productId,
                            name: group.findOne('Text').text(),
                            x: group.x(),
                            y: group.y()
                        });
                    }
                });
                
                // Create floor plan object
                const floorPlan = {
                    locationId: currentLocation,
                    shapes: shapes,
                    placedProducts: placedProducts
                };
                
                console.log('Saving floor plan:', floorPlan);
                
                // Save to IndexedDB
                await db.put('floorPlans', floorPlan);
                
                // Verify the save by reading it back
                const savedPlan = await db.get('floorPlans', currentLocation);
                if (savedPlan) {
                    console.log('Floor plan saved and verified:', savedPlan);
                    alert('Floor plan saved successfully!');
                } else {
                    throw new Error('Floor plan was not saved correctly');
                }
            } catch (error) {
                console.error('Error saving floor plan:', error);
                alert('Error saving floor plan: ' + error.message);
            }
        }

        function selectTool(tool) {
            currentTool = tool;
            
            console.log("Tool selected:", tool);
            
            // Update active button and canvas cursor
            document.querySelectorAll('.shape-button').forEach(button => {
                if (button.dataset.tool === tool) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
                
                // Reset any special class
                button.classList.remove('delete-tool');
            });
            
            // Set special styling for delete tool
            if (tool === 'delete') {
                document.querySelector('[data-tool="delete"]').classList.add('delete-tool');
                stage.container().classList.add('delete-cursor');
            } else {
                stage.container().classList.remove('delete-cursor');
            }
            
            // Clear selection when changing tools (except for select tool)
            if (tool !== 'select' && transformer) {
                transformer.nodes([]);
                selectedShape = null;
                layer.draw();
            }
        }

        function deleteSelected() {
            if (!selectedShape) return;
            
            try {
                // First remove from transformer to prevent errors
                transformer.nodes([]);
                
                // Remove from konvaShapes array if it's a basic shape
                const index = konvaShapes.indexOf(selectedShape);
                if (index > -1) {
                    konvaShapes.splice(index, 1);
                }
                
                // If it's a product group, remove from placedProducts
                if (selectedShape instanceof Konva.Group && selectedShape.attrs.productId) {
                    const productId = selectedShape.attrs.productId;
                    placedProducts = placedProducts.filter(p => p.productId !== productId);
                }
                
                // Remove the shape from the layer
                selectedShape.destroy();
                selectedShape = null;
                
                // Redraw the layer
                layer.draw();
                
                console.log("Shape deleted successfully");
            } catch (error) {
                console.error("Error deleting shape:", error);
                // Reset the state
                transformer.nodes([]);
                selectedShape = null;
                layer.draw();
            }
        }

        function clearFloorPlan() {
            if (confirm('Are you sure you want to clear the entire floor plan?')) {
                konvaShapes = [];
                layer.destroyChildren();
                layer.add(transformer);
                layer.draw();
                shapes = [];
                placedProducts = [];
            }
        }

        function loadProductsForPlacement() {
            const productList = document.getElementById('productList');
            productList.innerHTML = '';
            
            // Get products with inventory in this location
            const productsInLocation = inventoryItems
                .filter(item => item.locationId === currentLocation && item.quantity > 0)
                .map(item => {
                    const product = products.find(p => p.id === item.productId);
                    return product ? {
                        id: product.id,
                        name: product.name,
                        quantity: item.quantity
                    } : null;
                })
                .filter(Boolean);
            
            productsInLocation.forEach(product => {
                const productItem = document.createElement('div');
                productItem.className = 'product-item';
                productItem.innerHTML = `
                    <span>${product.name}</span>
                    <span>(Qty: ${product.quantity})</span>
                `;
                productItem.dataset.productId = product.id;
                productItem.dataset.productName = product.name;
                
                productItem.draggable = true;
                productItem.addEventListener('dragstart', onDragStart);
                
                productList.appendChild(productItem);
            });
            
            // Make canvas container droppable
            const canvasContainer = document.querySelector('.floor-plan-canvas-container');
            canvasContainer.addEventListener('dragover', onDragOver);
            canvasContainer.addEventListener('drop', onDrop);
        }

        function onDragStart(e) {
            e.dataTransfer.setData('productId', e.target.dataset.productId);
            e.dataTransfer.setData('productName', e.target.dataset.productName);
        }
        
        function onDragOver(e) {
            e.preventDefault();
        }
        
        function onDrop(e) {
            e.preventDefault();
            
            const productId = e.dataTransfer.getData('productId');
            const productName = e.dataTransfer.getData('productName');
            
            if (!productId || !productName) {
                console.error("Missing product data in drop event");
                return;
            }
            
            try {
                // Get position relative to the canvas container
                const rect = stage.container().getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                console.log("Dropping product at position:", x, y);
                
                // Create product text
                const productText = new Konva.Text({
                    x: 0,
                    y: 0,
                    text: productName,
                    fontSize: 14,
                    padding: 5,
                    fill: '#ffffff'
                });
                
                // Create product background
                const productBox = new Konva.Rect({
                    x: 0,
                    y: 0,
                    width: productText.width(),
                    height: productText.height(),
                    fill: '#2196F3',
                    opacity: 0.7,
                    cornerRadius: 3
                });
                
                // Group product text and box
                const productGroup = new Konva.Group({
                    x: x,
                    y: y,
                    draggable: true,
                    name: 'productGroup',
                    productId: productId
                });
                
                productGroup.add(productBox);
                productGroup.add(productText);
                
                // Make sure the group is recognized as a shape for selection and dragging
                productGroup.listening(true);
                
                // Add custom drag events to prevent transformer errors
                productGroup.off('dragstart'); // Clear any existing handlers
                productGroup.off('dragend');
                
                productGroup.on('dragstart', function() {
                    console.log('Product drag started');
                    // Remove the transformer during drag to prevent errors
                    transformer.nodes([]);
                });
                
                productGroup.on('dragend', function() {
                    console.log('Product drag ended, current tool:', currentTool);
                    
                    // Only add the transformer back if in select mode
                    if (currentTool === 'select') {
                        transformer.nodes([productGroup]);
                        selectedShape = productGroup;
                    }
                    
                    // Update product position in placedProducts array
                    const product = placedProducts.find(p => p.productId === productId);
                    if (product) {
                        product.x = productGroup.x();
                        product.y = productGroup.y();
                    }
                    
                    layer.draw();
                });
                
                // Add to layer and draw
                layer.add(productGroup);
                
                // Select the newly created product if in select mode
                if (currentTool === 'select') {
                    transformer.nodes([productGroup]);
                    selectedShape = productGroup;
                } else if (currentTool !== 'delete') {
                    // Switch to select tool if not in delete mode
                    selectTool('select');
                }
                
                layer.draw();
                
                console.log("Product placed:", productName, "at", x, y);
                
                // Add to placedProducts array
            placedProducts.push({
                productId: productId,
                name: productName,
                x: x,
                y: y
            });
            } catch (error) {
                console.error("Error placing product:", error);
            }
        }

        function viewFloorPlan() {
            // Toggle edit mode
            isEditMode = !isEditMode;
            
            // Update UI
            const editElements = document.querySelectorAll('.floor-plan-tools, .product-placement-panel');
            editElements.forEach(el => {
                el.style.display = isEditMode ? 'flex' : 'none';
            });
            
            document.querySelector('.floor-plan-actions').innerHTML = isEditMode
                ? `<button onclick="saveFloorPlan()">Save Floor Plan</button>
                   <button onclick="viewFloorPlan()">View Mode</button>`
                : `<button onclick="viewFloorPlan()">Edit Mode</button>
                   <button onclick="closeFloorPlan()">Close</button>`;
            
            try {
                // Remove transformer when switching to view mode
                if (!isEditMode) {
                    transformer.nodes([]);
                    selectedShape = null;
                }
                
                // Update Konva shapes and product groups
                konvaShapes.forEach(shape => {
                    if (shape && typeof shape.draggable === 'function') {
                        shape.draggable(isEditMode);
                    }
                });
                
                // Update product groups
                layer.find('.Group').forEach(group => {
                    if (group && typeof group.draggable === 'function') {
                        group.draggable(isEditMode);
                    }
                });
                
                // Toggle transformer visibility
                transformer.visible(isEditMode);
                
                layer.draw();
            } catch (error) {
                console.error("Error updating view mode:", error);
            }
        }

        function changeUser(selectedUserId) {
            if (!selectedUserId && users.length > 0) {
                // If somehow no user is selected, select the first one
                selectedUserId = users[0].id;
                document.getElementById('userSelect').value = selectedUserId;
            }
            currentUserId = selectedUserId;
            currentUser = users.find(user => user.id === selectedUserId)?.name || '';
            updateTable();
        }
        
        async function renameUser() {
            const userSelect = document.getElementById('userSelect');
            const selectedUserName = userSelect.value;
            const selectedUser = users.find(user => user.name === selectedUserName);
            
            if (!selectedUser) return;
            
            const newName = prompt("Enter new name for " + selectedUserName + ":", selectedUserName);
            
            if (newName && newName.trim() !== "") {
                // Update option text
                const selectedOption = userSelect.options[userSelect.selectedIndex];
                selectedOption.text = newName;
                selectedOption.value = newName;
                
                // Update in users array
                selectedUser.name = newName;
                
                // Update current user
                currentUser = newName;
                
                // Update in history
                updateUserInHistory(selectedUserName, newName);
                
                // Save to IndexedDB
                await saveToIndexedDB('users', users);
                
                console.log('User renamed from', selectedUserName, 'to', newName);
            }
        }
        
        async function addUser() {
            const userSelect = document.getElementById('userSelect');
            const newName = prompt("Enter name for new user:", "");
            
            if (newName && newName.trim() !== "") {
                // Create new user object
                const newUser = {
                    id: 'user-' + Date.now(),
                    name: newName
                };
                
                // Add to users array
                users.push(newUser);
                
                // Create new option
                const option = document.createElement('option');
                option.text = newName;
                option.value = newName;
                userSelect.add(option);
                
                // Select the new user
                userSelect.value = newName;
                currentUser = newName;
                currentUserId = newUser.id;
                
                // Save to IndexedDB
                await saveToIndexedDB('users', users);
                
                console.log('New user added:', newName, '(ID:', newUser.id, ')');
            }
        }
        
        async function deleteUser() {
            const userSelect = document.getElementById('userSelect');
            
            // Prevent deleting if only one user remains
            if (userSelect.options.length <= 1) {
                alert("Cannot delete the last user.");
                return;
            }
            
            const selectedUserName = userSelect.value;
            const userIndex = users.findIndex(user => user.name === selectedUserName);
            
            if (userIndex === -1) return;
            
            if (confirm("Are you sure you want to delete user: " + selectedUserName + "?")) {
                // Remove from users array
                users.splice(userIndex, 1);
                
                // Remove the selected option
                userSelect.remove(userSelect.selectedIndex);
                
                // Update current user to the first available
                currentUser = userSelect.value;
                const newSelectedUser = users.find(user => user.name === currentUser);
                if (newSelectedUser) {
                    currentUserId = newSelectedUser.id;
                }
                
                // Save to IndexedDB
                await saveToIndexedDB('users', users);
                
                console.log('User deleted:', selectedUserName);
            }
        }
        
        function updateUserInHistory(oldName, newName) {
            // Update username in transaction history
            for (const transaction of transactions) {
                if (transaction.user === oldName) {
                    transaction.user = newName;
                }
            }
            
            // Update the display
            updateHistory();
            
            // Save changes
            save();
        }
        
        async function loadUsers() {
            try {
                users = await loadFromIndexedDB('users') || [];
                const userSelect = document.getElementById('userSelect');
                
                // Only update the user selector if it exists
                if (userSelect) {
                    userSelect.innerHTML = '';
                    users.forEach(user => {
                        const option = document.createElement('option');
                        option.value = user.id;
                        option.textContent = user.name;
                        if (user.id === currentUserId) {
                            option.selected = true;
                        }
                        userSelect.appendChild(option);
                    });

                    // If no user is selected, select the first one
                    if (!currentUserId && users.length > 0) {
                        currentUserId = users[0].id;
                        currentUser = users[0].name;
                        userSelect.value = currentUserId;
                    }
                }
                
                // Update the table to reflect any user changes
                updateTable();
            } catch (error) {
                console.error('Error loading users:', error);
            }
        }

        // Export/Import Functions
        async function exportData() {
            try {
                // Collect all data from IndexedDB
                const exportData = {
                    products: await loadFromIndexedDB('products') || [],
                    locations: await loadFromIndexedDB('locations') || [],
                    inventory: await loadFromIndexedDB('inventory') || [],
                    transactions: await loadFromIndexedDB('transactions') || [],
                    users: await loadFromIndexedDB('users') || [],
                    floorPlans: await loadFromIndexedDB('floorPlans') || [],
                    exportDate: new Date().toISOString(),
                    appVersion: '1.0.0'
                };
                
                // Convert to JSON string
                const jsonData = JSON.stringify(exportData, null, 2);
                
                // Create blob and download link
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Format date for filename
                const date = new Date();
                const dateStr = date.toISOString().split('T')[0];
                
                // Create download link
                const a = document.createElement('a');
                a.href = url;
                a.download = `inventory_export_${dateStr}.json`;
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
                
                console.log('Data exported successfully');
            } catch (error) {
                console.error('Error exporting data:', error);
                alert('Error exporting data: ' + error.message);
            }
        }
        
        function importData() {
            // Trigger file input click
            const importFile = document.getElementById('settingsImportFile');
            if (importFile) {
                importFile.click();
            } else {
                console.error('Import file input not found');
                alert('Error: Import functionality not available');
            }
        }
        
        async function handleImportFile(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;
                
                // Confirm before importing
                if (!confirm('Importing data will replace all current data. Continue?')) {
                    event.target.value = null;
                    return;
                }
                
                // Start import immediately after confirmation
                const reader = new FileReader();
                
                reader.onload = async (e) => {
                    try {
                        // Parse JSON data
                        const importData = JSON.parse(e.target.result);
                        
                        // Validate data structure
                        if (!importData.products || !importData.locations || !importData.inventory) {
                            throw new Error('Invalid import file format');
                        }
                        
                        // Import each store
                        if (importData.products && Array.isArray(importData.products)) {
                            await saveToIndexedDB('products', importData.products);
                            products = importData.products;
                        }
                        
                        if (importData.locations && Array.isArray(importData.locations)) {
                            await saveToIndexedDB('locations', importData.locations);
                            locations = importData.locations;
                        }
                        
                        if (importData.inventory && Array.isArray(importData.inventory)) {
                            await saveToIndexedDB('inventory', importData.inventory);
                            inventoryItems = importData.inventory;
                        }
                        
                        if (importData.transactions && Array.isArray(importData.transactions)) {
                            await saveToIndexedDB('transactions', importData.transactions);
                            transactions = importData.transactions;
                        }
                        
                        if (importData.users && Array.isArray(importData.users)) {
                            await saveToIndexedDB('users', importData.users);
                            users = importData.users;
                        }
                        
                        if (importData.floorPlans && Array.isArray(importData.floorPlans)) {
                            // Clear existing floor plans
                            const tx = db.transaction('floorPlans', 'readwrite');
                            await tx.objectStore('floorPlans').clear();
                            await tx.done;
                            
                            // Import floor plans
                            for (const floorPlan of importData.floorPlans) {
                                await db.put('floorPlans', floorPlan);
                            }
                        }
                        
                        // Set current location to first available
                        if (locations.length > 0) {
                            currentLocation = locations[0].id;
                        }
                        
                        // Update UI
                        await loadUsers();
                        updateLocationSelect();
                        updateTable();
                        updateHistory();
                        
                        console.log('Data imported successfully');
                        alert('Data imported successfully!');
                        
                        // Close settings modal if it's open
                        closeSettings();
                    } catch (error) {
                        console.error('Error parsing import file:', error);
                        alert('Error importing data: ' + error.message);
                    }
                };
                
                reader.onerror = () => {
                    console.error('Error reading file');
                    alert('Error reading file');
                };
                
                reader.readAsText(file);
                
                // Reset file input
                event.target.value = null;
            } catch (error) {
                console.error('Error handling import file:', error);
                alert('Error handling import file: ' + error.message);
            }
        }

        // Add ESC key support for settings modal
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                const settingsModal = document.getElementById('settingsModal');
                if (settingsModal.style.display === 'block') {
                    closeSettings();
                } else {
                    openSettings();
                }
            }
        });

        // Barcode Scanner Variables
        let scannerStream = null;
        let scannerInterval = null;
        let currentCameraIndex = 0;
        let availableCameras = [];
        
        
        // Store the ZXing reader instance
        let codeReader = null;
        
        // Look up a product by barcode
        function lookupProductByBarcode(barcode) {
            // In a real implementation, you would look up the product in your database
            // For now, we'll just search for a product with a matching ID
            
            const product = products.find(p => p.id === barcode || p.barcode === barcode);
            
            if (product) {
                // Product found, scroll to it in the table
                const productRow = document.querySelector(`tr[data-product-id="${product.id}"]`);
                if (productRow) {
                    productRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    productRow.classList.add('highlight-row');
                    setTimeout(() => {
                        productRow.classList.remove('highlight-row');
                    }, 2000);
                }
                
                // Add to history
                addToHistory({
                    type: 'scan_barcode',
                    productId: product.id,
                    productName: product.name,
                    barcode: barcode,
                    timestamp: new Date().toISOString()
                });
            } else {
                // Product not found, ask if user wants to add it
                if (confirm(`No product found with barcode ${barcode}. Would you like to add it?`)) {
                    // Pre-fill the add item form
                    document.getElementById('itemName').value = `Product ${barcode}`;
                    document.getElementById('itemQuantity').value = '1';
                    document.getElementById('itemPrice').value = '0.00';
                    
                    // Focus on the name field for editing
                    document.getElementById('itemName').focus();
                }
            }
        }
        
        // Add this to the style section
        document.head.insertAdjacentHTML('beforeend', `
            <style>
                .highlight-row {
                    animation: highlight 2s ease-out;
                }
                
                @keyframes highlight {
                    0% { background-color: rgba(255, 255, 0, 0.5); }
                    100% { background-color: transparent; }
                }
            </style>
        `);

        // Add barcode assignment functions
        let currentBarcodeProductId = null;
        let currentScannedBarcode = null;

        function openBarcodeModal(productId) {
            const product = products.find(p => p.id === productId);
            if (!product) return;
            
            currentBarcodeProductId = productId;
            document.getElementById('barcodeProductName').textContent = product.name;
            document.getElementById('barcodeInput').value = product.barcode || '';
            document.getElementById('barcodeModal').style.display = 'block';
            document.getElementById('barcodeInput').focus();
        }

        function showBarcodeAssignmentModal(barcode) {
            // Create a select dropdown with all products
            const modal = document.getElementById('assignBarcodeModal') || createAssignBarcodeModal();
            const productSelect = document.getElementById('assignBarcodeProductSelect');
            
            // Clear previous options
            productSelect.innerHTML = '';
            
            // Add options for all products without barcodes
            products.forEach(product => {
                const option = document.createElement('option');
                option.value = product.id;
                option.textContent = product.name;
                productSelect.appendChild(option);
            });
            
            // Set the scanned barcode
            currentScannedBarcode = barcode;
            document.getElementById('assignBarcodeValue').textContent = barcode;
            
            // Show modal
            modal.style.display = 'block';
        }

        function createAssignBarcodeModal() {
            // Create modal if it doesn't exist
            const modal = document.createElement('div');
            modal.id = 'assignBarcodeModal';
            modal.className = 'modal';
            
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Assign Barcode</h2>
                        <span class="close" onclick="closeAssignBarcodeModal()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <p>Barcode: <strong id="assignBarcodeValue"></strong></p>
                        <p>Select product to assign this barcode to:</p>
                        <select id="assignBarcodeProductSelect" class="form-control"></select>
                    </div>
                    <div class="modal-footer">
                        <button onclick="assignBarcodeToExistingProduct()">Assign Barcode</button>
                        <button onclick="closeAssignBarcodeModal()">Cancel</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            return modal;
        }

        function closeAssignBarcodeModal() {
            const modal = document.getElementById('assignBarcodeModal');
            if (modal) modal.style.display = 'none';
            currentScannedBarcode = null;
        }

        async function assignBarcodeToExistingProduct() {
            const productId = document.getElementById('assignBarcodeProductSelect').value;
            const product = products.find(p => p.id === productId);
            
            if (!product || !currentScannedBarcode) return;
            
            // Update the product barcode
            const oldBarcode = product.barcode || '';
            product.barcode = currentScannedBarcode;
            
            // Add to history
            await addToHistory({
                type: 'assign_barcode',
                productId: product.id,
                productName: product.name,
                oldValue: oldBarcode,
                newValue: currentScannedBarcode,
                timestamp: new Date().toISOString()
            });
            
            // Save to database
            await save();
            
            // Close modal
            closeAssignBarcodeModal();
            closeBarcodeScanner();
            
            // Show success message
            alert(`Barcode ${currentScannedBarcode} assigned to ${product.name}`);
            
            // Update UI
            updateTable();
        }

        async function assignBarcodeToNewProduct(barcode) {
            // Pre-fill the item form
            document.getElementById('itemName').value = `Product ${barcode}`;
            document.getElementById('itemQuantity').value = '1';
            document.getElementById('itemPrice').value = '0.00';
            
            // Close barcode scanner
            closeBarcodeScanner();
            
            // Focus on the name field
            document.getElementById('itemName').focus();
            
            // Create a new product with the barcode
            const product = { 
                id: Date.now().toString(),
                name: `Product ${barcode}`,
                price: 0,
                comments: '',
                barcode: barcode,
            };
            
            // Add to products array
            products.push(product);
            
            // Add to history
            await addToHistory({
                type: 'create_product',
                productId: product.id,
                productName: product.name,
                barcode: barcode,
                timestamp: new Date().toISOString()
            });
            
            // Save to database
            await save();
            
            // Update UI
            updateTable();
            
            // Show success message
            alert(`New product created with barcode ${barcode}. Please update the details.`);
        }

        function closeBarcodeModal() {
            document.getElementById('barcodeModal').style.display = 'none';
            currentBarcodeProductId = null;
        }

        async function saveBarcode() {
            if (!currentBarcodeProductId) return;
            
            const barcode = document.getElementById('barcodeInput').value.trim();
            const product = products.find(p => p.id === currentBarcodeProductId);
            
            if (!product) return;
            
            // Check if barcode already exists on another product
            const existingProduct = products.find(p => p.barcode === barcode && p.id !== currentBarcodeProductId);
            if (barcode && existingProduct) {
                if (!confirm(`This barcode is already assigned to product "${existingProduct.name}". Do you want to reassign it?`)) {
                    return;
                }
                
                // Remove barcode from existing product
                const oldBarcode = existingProduct.barcode;
                existingProduct.barcode = '';
                
                // Add to history
                await addToHistory({
                    type: 'remove_barcode',
                    productId: existingProduct.id,
                    productName: existingProduct.name,
                    oldValue: oldBarcode,
                    newValue: '',
                    timestamp: new Date().toISOString()
                });
            }
            
            const oldBarcode = product.barcode || '';
            product.barcode = barcode;
            
            await addToHistory({
                type: 'assign_barcode',
                productId: product.id,
                productName: product.name,
                oldValue: oldBarcode,
                newValue: barcode,
                timestamp: new Date().toISOString()
            });
            
            await save();
            closeBarcodeModal();
            updateTable();
        }

        // Settings Functions
        function openSettings() {
            const modal = document.getElementById('settingsModal');
            modal.style.display = 'block';
            
            // Update theme toggle state
            document.getElementById('settingsThemeCheckbox').checked = currentTheme === 'dark';
            
            // Load users and locations lists
            updateUsersList();
            updateLocationsList();
        }
        
        function closeSettings() {
            const modal = document.getElementById('settingsModal');
            modal.style.display = 'none';
        }
        
        function switchSettingsTab(tabName) {
            // Hide all panels
            document.querySelectorAll('.settings-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Deactivate all tabs
            document.querySelectorAll('.settings-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected panel
            document.getElementById(tabName + 'Settings').classList.add('active');
            
            // Activate selected tab
            document.querySelector(`.settings-tab[onclick="switchSettingsTab('${tabName}')"]`).classList.add('active');
        }
        
        function updateUsersList() {
            const usersList = document.getElementById('usersList');
            usersList.innerHTML = '';
            
            users.forEach(user => {
                const listItem = document.createElement('div');
                listItem.className = 'settings-list-item';
                
                const isCurrentUser = user.name === currentUser;
                
                listItem.innerHTML = `
                    <span>${user.name}${isCurrentUser ? ' (Current)' : ''}</span>
                    <div class="item-actions">
                        ${!isCurrentUser ? `
                            <button onclick="renameUserFromSettings('${user.id}')">Rename</button>
                            <button onclick="deleteUserFromSettings('${user.id}')" class="danger-btn">Delete</button>
                        ` : ''}
                    </div>
                `;
                
                usersList.appendChild(listItem);
            });
        }
        
        function updateLocationsList() {
            const locationsList = document.getElementById('locationsList');
            locationsList.innerHTML = '';
            
            locations.forEach(location => {
                const listItem = document.createElement('div');
                listItem.className = 'settings-list-item';
                
                const isCurrentLocation = location.id === currentLocation;
                
                listItem.innerHTML = `
                    <span>${location.name}${isCurrentLocation ? ' (Current)' : ''}</span>
                    <div class="item-actions">
                        ${!isCurrentLocation ? `
                            <button onclick="renameLocationFromSettings('${location.id}')">Rename</button>
                            <button onclick="deleteLocationFromSettings('${location.id}')" class="danger-btn">Delete</button>
                        ` : ''}
                    </div>
                `;
                
                locationsList.appendChild(listItem);
            });
        }
        
        async function addUserFromSettings() {
            const nameInput = document.getElementById('newUserName');
            const newName = nameInput.value.trim();
            
            if (!newName) {
                alert('Please enter a user name');
                return;
            }
            
            // Check if name already exists
            if (users.some(user => user.name === newName)) {
                alert('A user with this name already exists');
                return;
            }
            
            // Create new user object
            const newUser = {
                id: 'user-' + Date.now(),
                name: newName
            };
            
            // Add to users array
            users.push(newUser);
            
            // Save to IndexedDB
            await saveToIndexedDB('users', users);
            
            // Update UI
            updateUsersList();
            nameInput.value = '';
            
            // Update user dropdown
            await loadUsers();
        }
        
        async function renameUserFromSettings(userId) {
            const user = users.find(u => u.id === userId);
            if (!user) return;
            
            const newName = prompt("Enter new name for " + user.name + ":", user.name);
            
            if (newName && newName.trim() !== "") {
                // Check if name already exists
                if (users.some(u => u.id !== userId && u.name === newName)) {
                    alert('A user with this name already exists');
                    return;
                }
                
                // Update in users array
                user.name = newName;
                
                // Update current user if needed
                if (user.id === currentUserId) {
                    currentUser = newName;
                }
                
                // Update in history
                updateUserInHistory(user.name, newName);
                
                // Save to IndexedDB
                await saveToIndexedDB('users', users);
                
                // Update UI
                updateUsersList();
                
                // Update user dropdown
                await loadUsers();
            }
        }
        
        async function deleteUserFromSettings(userId) {
            const user = users.find(u => u.id === userId);
            if (!user) return;
            
            // Prevent deleting if only one user remains
            if (users.length <= 1) {
                alert("Cannot delete the last user.");
                return;
            }
            
            if (confirm("Are you sure you want to delete user: " + user.name + "?")) {
                // Remove from users array
                users = users.filter(u => u.id !== userId);
                
                // Update current user if needed
                if (userId === currentUserId) {
                    currentUser = users[0].name;
                    currentUserId = users[0].id;
                }
                
                // Save to IndexedDB
                await saveToIndexedDB('users', users);
                
                // Update UI
                updateUsersList();
                
                // Update user dropdown
                await loadUsers();
            }
        }
        
        async function addLocationFromSettings() {
            const nameInput = document.getElementById('newLocationName');
            const newName = nameInput.value.trim();
            
            if (!newName) {
                alert('Please enter a location name');
                return;
            }
            
            // Check if name already exists
            if (locations.some(loc => loc.name === newName)) {
                alert('A location with this name already exists');
                return;
            }
            
            // Create new location
            const newLocationId = String(Date.now());
            const newLocation = {
                id: newLocationId,
                name: newName
            };
            
            // Add to locations array
            locations.push(newLocation);
            
            // Save to IndexedDB
            await saveToIndexedDB('locations', locations);
            
            // Update UI
            updateLocationsList();
            nameInput.value = '';
            
            // Update location dropdown
            updateLocationSelect();
        }
        
        async function renameLocationFromSettings(locationId) {
            const location = locations.find(loc => loc.id === locationId);
            if (!location) return;
            
            const newName = prompt("Enter new name for " + location.name + ":", location.name);
            
            if (newName && newName.trim() !== "") {
                // Check if name already exists
                if (locations.some(loc => loc.id !== locationId && loc.name === newName)) {
                    alert('A location with this name already exists');
                    return;
                }
                
                const oldName = location.name;
                location.name = newName;
                
                await addToHistory({
                    type: 'rename_location',
                    locationId: locationId,
                    oldName: oldName,
                    newName: newName,
                    timestamp: new Date().toISOString()
                });
                
                // Save to IndexedDB
                await saveToIndexedDB('locations', locations);
                
                // Update UI
                updateLocationsList();
                
                // Update location dropdown
                updateLocationSelect();
            }
        }
        
        async function deleteLocationFromSettings(locationId) {
            const location = locations.find(loc => loc.id === locationId);
            if (!location) return;
            
            // Prevent deleting if only one location remains
            if (locations.length <= 1) {
                alert("Cannot delete the last location.");
                return;
            }
            
            if (confirm("Are you sure you want to delete location: " + location.name + "? All inventory items in this location will be deleted.")) {
                // Remove inventory items for this location
                inventoryItems = inventoryItems.filter(item => item.locationId !== locationId);
                
                // Remove the location
                locations = locations.filter(loc => loc.id !== locationId);
                
                // Update current location if needed
                if (locationId === currentLocation) {
                    currentLocation = locations[0].id;
                }
                
                await addToHistory({
                    type: 'delete_location',
                    location: location,
                    timestamp: new Date().toISOString()
                });
                
                // Save to IndexedDB
                await saveToIndexedDB('locations', locations);
                await saveToIndexedDB('inventory', inventoryItems);
                
                // Update UI
                updateLocationsList();
                
                // Update location dropdown
                updateLocationSelect();
                updateTable();
            }
        }
        
        async function confirmClearData() {
            if (confirm("Are you sure you want to clear all data? This action cannot be undone.")) {
                if (confirm("FINAL WARNING: All your data will be permanently deleted. Continue?")) {
                    try {
                        // Clear all object stores
                        await db.clear('products');
                        await db.clear('locations');
                        await db.clear('inventory');
                        await db.clear('transactions');
                        await db.clear('floorPlans');
                        
                        // Reset arrays
                        products = [];
                        locations = [{ id: '1', name: 'Location 1' }];
                        inventoryItems = [];
                        transactions = [];
                        currentLocation = '1';
                        
                        // Save default location
                        await saveToIndexedDB('locations', locations);
                        
                        // Update UI
                        updateLocationSelect();
                        updateTable();
                        updateHistory();
                        
                        alert('All data has been cleared. The application has been reset to default settings.');
                    } catch (error) {
                        console.error('Error clearing data:', error);
                        alert('Error clearing data: ' + error.message);
                    }
                }
            }
        }

        // Function to open scanner modal and start scanning
        function openBarcodeScanner() {
            // Reset previous results
            document.getElementById('scannerResult').textContent = '';
            document.getElementById('productResult').textContent = '';
            
            // Show the scanner modal
            document.getElementById('scannerModal').style.display = 'block';
            
            // Get video element
            const videoElement = document.getElementById('video');
            
            // Create instance of the reader
            codeReader = new window.BrowserMultiFormatReader();
            
            // Get available video devices
            codeReader.listVideoInputDevices()
                .then(videoInputDevices => {
                    if (videoInputDevices.length === 0) {
                        alert('No camera devices found');
                        closeBarcodeScanner();
                        return;
                    }
                    
                    // Use first device by default
                    const firstDeviceId = videoInputDevices[0].deviceId;
                    
                    // Start decoding from video device
                    codeReader.decodeFromVideoDevice(firstDeviceId, videoElement, (result, error) => {
                        if (result) {
                            // Barcode found!
                            const barcode = result.getText();
                            document.getElementById('scannerResult').textContent = `Found barcode: ${barcode}`;
                            
                            // Look up product by barcode
                            const product = products.find(p => p.barcode === barcode);
                            if (product) {
                                document.getElementById('productResult').innerHTML = `
                                    <div class="alert alert-success mt-3">
                                        <h4>${product.name}</h4>
                                        <p>Price: ${product.price}</p>
                                        <p>Stock: ${product.stock}</p>
                                    </div>
                                `;
                                
                                // Automatically stop scanning after finding a valid barcode
                                closeBarcodeScanner();
                            } else {
                                // No product found with this barcode
                                document.getElementById('productResult').innerHTML = `
                                    <div class="alert alert-warning mt-3">
                                        <p>Product with barcode ${barcode} not found</p>
                                        <button class="btn btn-primary" onclick="assignBarcodeToNewProduct('${barcode}')">Create New Product</button>
                                        <button class="btn btn-secondary" onclick="showBarcodeAssignmentModal('${barcode}')">Assign to Existing Product</button>
                                    </div>
                                `;
                            }
                        }
                        
                        if (error && !(error instanceof window.NotFoundException)) {
                            // Only log critical errors, not the common "not found" errors
                            console.error('ZXing error:', error);
                        }
                    });
                })
                .catch(err => {
                    console.error('Error accessing camera:', err);
                    alert('Error accessing camera: ' + err);
                    closeBarcodeScanner();
                });
        }

        // Function to close scanner and clean up
        function closeBarcodeScanner() {
            // Hide the scanner modal
            document.getElementById('scannerModal').style.display = 'none';
            
            // Stop the scanner if it's running
            if (codeReader) {
                codeReader.reset();
                codeReader = null;
            }
        }
        
        // Function to switch between available cameras
        function switchCamera() {
            if (!codeReader) return;
            
            // Get available cameras
            codeReader.listVideoInputDevices()
                .then(videoInputDevices => {
                    availableCameras = videoInputDevices;
                    
                    if (availableCameras.length <= 1) {
                        alert('Only one camera available');
                        return;
                    }
                    
                    // Reset the scanner
                    codeReader.reset();
                    
                    // Switch to next camera
                    currentCameraIndex = (currentCameraIndex + 1) % availableCameras.length;
                    const nextDeviceId = availableCameras[currentCameraIndex].deviceId;
                    
                    // Get video element
                    const videoElement = document.getElementById('video');
                    
                    // Start decoding from the new camera
                    codeReader.decodeFromVideoDevice(nextDeviceId, videoElement, (result, error) => {
                        if (result) {
                            // Barcode found!
                            const barcode = result.getText();
                            document.getElementById('scannerResult').textContent = `Found barcode: ${barcode}`;
                            
                            // Look up product by barcode
                            const product = products.find(p => p.barcode === barcode);
                            if (product) {
                                document.getElementById('productResult').innerHTML = `
                                    <div class="alert alert-success mt-3">
                                        <h4>${product.name}</h4>
                                        <p>Price: ${product.price}</p>
                                        <p>Stock: ${product.stock}</p>
                                    </div>
                                `;
                                
                                // Automatically stop scanning after finding a valid barcode
                                closeBarcodeScanner();
                            } else {
                                // No product found with this barcode
                                document.getElementById('productResult').innerHTML = `
                                    <div class="alert alert-warning mt-3">
                                        <p>Product with barcode ${barcode} not found</p>
                                        <button class="btn btn-primary" onclick="assignBarcodeToNewProduct('${barcode}')">Create New Product</button>
                                        <button class="btn btn-secondary" onclick="showBarcodeAssignmentModal('${barcode}')">Assign to Existing Product</button>
                                    </div>
                                `;
                            }
                        }
                        
                        if (error && !(error instanceof window.NotFoundException)) {
                            // Only log critical errors, not the common "not found" errors
                            console.error('ZXing error:', error);
                        }
                    });
                    
                    document.getElementById('scanner-status').textContent = `Using camera ${currentCameraIndex + 1} of ${availableCameras.length}`;
                })
                .catch(err => {
                    console.error('Error accessing cameras:', err);
                    alert('Error accessing cameras: ' + err);
                });
        }
    </script>
</body>
</html> 