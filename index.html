<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inventory System</title>
    <link rel="stylesheet" href="style.css">
    <script src="js/localization.js"></script>
</head>
<body>
    <div class="container">
        <h1>Inventory System</h1>
        
        <div class="top-actions">
            <div class="user-select">
                <span data-i18n="Current User:">Current User: </span>
                <select id="userSelect" onchange="changeUser(this.value)"></select>
            </div>
            <div class="location-select">
                <button onclick="openFloorPlan()" class="floor-plan-button" data-i18n="Floor Plan">Floor Plan</button>
            </div>
            <div class="data-actions">
                <button onclick="openBarcodeScanner()" data-i18n="Scan Barcode">Scan Barcode</button>
                <button onclick="openSettings()">‚öôÔ∏è <span data-i18n="Settings">Settings</span></button>
            </div>
        </div>

        <div class="search-container">
            <input type="text" id="searchInput" placeholder="Search items..." data-i18n-placeholder="Search items...">
        </div>
        <div id="totalFoundContainer" style="margin-left: 10px; margin-bottom: 10px; font-size: 1em; color: #555;"></div>
        <div id="locationFilterButtons" class="location-filter-buttons"></div>

        <div id="pendingInvoices" class="pending-invoices">
            <h2>Pending Invoices</h2>
            <div id="pendingInvoicesList"></div>
        </div>

        <div class="add-item-form">
            <input type="text" id="itemName" placeholder="Item Name" data-i18n-placeholder="Item Name">
            <input type="number" id="itemQuantity" placeholder="Quantity" data-i18n-placeholder="Quantity">
            <input type="number" id="itemPrice" placeholder="Price" data-i18n-placeholder="Price">
            <button onclick="addItem()">Add Item</button>
        </div>

        <table id="inventoryTable">
            <thead>
                <tr>
                    <th id="thName" onclick="setSort('name')">Name <span id="sortIconName"></span></th>
                    <th id="thQuantity" onclick="setSort('quantity')">Quantity <span id="sortIconQuantity"></span></th>
                    <th id="thPrice" onclick="setSort('price')">Price <span id="sortIconPrice"></span></th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="inventoryBody"></tbody>
        </table>
        <div id="inventoryPagination" class="pagination-controls"></div>

        <div class="history-section">
            <h2>Change History</h2>
            <div id="historyList"></div>
            <div id="historyPagination" class="pagination-controls"></div>
        </div>
    </div>

    <!-- Floor Plan Modal -->
    <div id="floorPlanModal" class="floor-plan-modal">
        <div class="floor-plan-content">
            <div class="floor-plan-header">
            <h2>Floor Plan - <span id="floorPlanLocationName"></span></h2>
                <div class="floor-plan-header-actions">
                    <button class="save-btn" onclick="saveFloorPlan()">Save Floor Plan</button>
                    <span class="floor-plan-close" onclick="closeFloorPlan()">&times;</span>
                </div>
            </div>
            
            <div class="floor-plan-editor">
                <div class="floor-plan-tools">
                    <button class="shape-button active" data-tool="select" onclick="selectTool('select')" data-i18n="Select">Select</button>
                    <button class="shape-button" data-tool="rectangle" onclick="selectTool('rectangle')" data-i18n="Rectangle">Rectangle</button>
                    <button class="shape-button" data-tool="circle" onclick="selectTool('circle')" data-i18n="Circle">Circle</button>
                    <button class="shape-button" data-tool="text" onclick="selectTool('text')" data-i18n="Text">Text</button>
                    <button class="shape-button" data-tool="delete" onclick="selectTool('delete')" data-i18n="Delete Floor Plan">Delete</button>
                    <input type="color" class="color-picker" id="shapeColor" value="#CCCCCC">
                    <div class="zoom-controls">
                        <button onclick="zoomFloorPlan(-0.1)" class="zoom-button">-</button>
                        <span id="zoomLevel">100%</span>
                        <button onclick="zoomFloorPlan(0.1)" class="zoom-button">+</button>
                        <button onclick="resetZoom()" class="zoom-button" data-i18n="Reset">Reset</button>
                    </div>
                    <div style="flex-grow: 1;"></div>
                    <button onclick="clearFloorPlan()" data-i18n="Clear All">Clear All</button>
                </div>
                
                <div class="floor-plan-canvas-container">
                    <div id="floorPlanCanvas" style="width: 1000px; height: 600px;"></div>
                    <div id="placedProducts"></div>
                </div>
                
                <div class="product-placement-panel">
                    <h3 data-i18n="Place Products on Floor Plan">Place Products on Floor Plan</h3>
                    <p data-i18n="Drag products onto the floor plan to show their locations">Drag products onto the floor plan to show their locations</p>
                    <div class="product-placement-list" id="productList"></div>
                </div>
                
                <div class="floor-plan-actions">
                    <button onclick="viewFloorPlan()" data-i18n="View Mode">View Mode</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add this after the floor plan modal -->
    <div id="scannerModal" class="scanner-modal">
        <div class="scanner-content">
            <span class="scanner-close" onclick="closeBarcodeScanner()">&times;</span>
            <h2 data-i18n="Scan Barcode">Scan Barcode</h2>
            
            <div id="scanner-container">
                <video id="video" autoplay playsinline></video>
                <canvas id="scanner-canvas"></canvas>
            </div>
            
            <div id="scannerResult" class="scanner-result"></div>
            <div id="productResult" class="product-result"></div>
            
            <div class="scanner-status" id="scanner-status" data-i18n="Ready to scan...">Ready to scan...</div>
            
            <div class="scanner-buttons">
                <button onclick="switchCamera()" class="switch-camera" data-i18n="Switch Camera">Switch Camera</button>
                <button onclick="closeBarcodeScanner()" data-i18n="Close">Close</button>
            </div>
        </div>
    </div>

    <!-- Add the barcode assignment modal -->
    <div id="barcodeModal" class="barcode-modal">
        <div class="barcode-content">
            <span class="barcode-close" onclick="closeBarcodeModal()">&times;</span>
            <h2 data-i18n="Assign Barcode">Assign Barcode</h2>
            <p id="barcodeProductName"></p>
            
            <div class="barcode-form">
                <div class="barcode-input-group">
                    <input type="text" id="barcodeInput" placeholder="Enter barcode" data-i18n-placeholder="Enter barcode">
                    <button class="scan-btn" onclick="scanBarcodeForProduct()"><i class="fas fa-camera"></i> <span data-i18n="Scan">Scan</span></button>
                </div>
                <button class="save-btn" onclick="saveBarcode()" data-i18n="Save Barcode">Save Barcode</button>
            </div>
        </div>
    </div>

    <!-- Add settings modal -->
    <div id="settingsModal" class="settings-modal">
        <div class="settings-content">
            <span class="settings-close" onclick="closeSettings()">&times;</span>
            <h2 data-i18n="Settings">Settings</h2>
            
            <div class="settings-tabs">
                <button class="settings-tab active" onclick="switchSettingsTab('theme')" data-i18n="settings_theme">Theme</button>
                <button class="settings-tab" onclick="switchSettingsTab('data')" data-i18n="settings_data">Data</button>
                <button class="settings-tab" onclick="switchSettingsTab('users')" data-i18n="settings_users">Users</button>
                <button class="settings-tab" onclick="switchSettingsTab('locations')" data-i18n="settings_locations">Locations</button>
            </div>
            
            <div id="themeSettings" class="settings-panel active">
                <h3 data-i18n="Theme Settings">Theme Settings</h3>
                <div class="settings-item">
                    <label data-i18n="Dark Mode">Dark Mode</label>
                    <div class="theme-toggle-container">
                        <label class="theme-toggle-label">üåô</label>
                        <label class="theme-toggle">
                            <input type="checkbox" id="settingsThemeCheckbox" onchange="toggleThemeFromSettings()">
                            <span class="theme-toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div id="dataSettings" class="settings-panel">
                <h3 data-i18n="Data Management">Data Management</h3>
                <div class="settings-item">
                    <label data-i18n="Export Data">Export Data</label>
                    <button onclick="exportData()" data-i18n="Export to JSON">Export to JSON</button>
                </div>
                <div class="settings-item">
                    <label data-i18n="Import Data">Import Data</label>
                    <button onclick="importData()" data-i18n="Import from JSON">Import from JSON</button>
                    <input type="file" id="settingsImportFile" accept=".json" style="display: none;" onchange="handleImportFile(event)">
                </div>
                <div class="settings-item">
                    <label data-i18n="Rebuild from History">Rebuild from History</label>
                    <button onclick="confirmRebuildFromHistory()" data-i18n="Rebuild">Rebuild</button>
                </div>
                <div class="settings-item">
                    <label data-i18n="Clear All Data">Clear All Data</label>
                    <button onclick="confirmClearData()" class="danger-btn" data-i18n="Clear Database">Clear Database</button>
                </div>
            </div>
            
            <div id="usersSettings" class="settings-panel">
                <h3 data-i18n="User Management">User Management</h3>
                <div class="settings-item">
                    <label data-i18n="Add New User">Add New User</label>
                    <div class="settings-input-group">
                        <input type="text" id="newUserName" placeholder="User Name" data-i18n-placeholder="User Name">
                        <button onclick="addUserFromSettings()" data-i18n="Add">Add</button>
                    </div>
                </div>
                <div class="settings-item">
                    <label data-i18n="Existing Users">Existing Users</label>
                    <div id="usersList" class="settings-list"></div>
                </div>
            </div>
            
            <div id="locationsSettings" class="settings-panel">
                <h3 data-i18n="Location Management">Location Management</h3>
                <div class="settings-item">
                    <label data-i18n="Add New Location">Add New Location</label>
                    <div class="settings-input-group">
                        <input type="text" id="newLocationName" placeholder="Location Name" data-i18n-placeholder="Location Name">
                        <button onclick="addLocationFromSettings()" data-i18n="Add">Add</button>
                    </div>
                </div>
                <div class="settings-item">
                    <label data-i18n="Existing Locations">Existing Locations</label>
                    <div id="locationsList" class="settings-list"></div>
                </div>
            </div>
            <div class="settings-item">
                <label data-i18n="settings_language">Language</label>
                <select id="languageSelect" onchange="changeLanguage(this.value)"></select>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/idb@8/build/umd.js"></script>
    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ericblade/quagga2/dist/quagga.min.js"></script>
    <script src="js/floorplan.js"></script>
    <script type="module">
        import { BrowserMultiFormatReader, NotFoundException } from 'https://cdn.jsdelivr.net/npm/@zxing/library@0.21.3/+esm';
        window.BrowserMultiFormatReader = BrowserMultiFormatReader;
        window.NotFoundException = NotFoundException;
    </script>
    <script src="js/barcode.js"></script>
    <script src="js/invoice.js"></script>

    <script>
        // Pagination state variables (must be declared before any function uses them)
        let inventoryPage = 1;
        let inventoryPageSize = 10;
        let historyPage = 1;
        let historyPageSize = 10;

        let products = [];
        let inventoryItems = [];
        let locations = [];
        let transactions = [];
        let users = [];
        let currentLocation = '';
        let currentUser = 'User 1';
        let currentUserId = '';
        let db;
        let currentTheme = localStorage.getItem('theme') || 'light';
        let locationFilter = null; // null = all, or location id

        // Set up theme on initial load
        function applyTheme() {
            if (currentTheme === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark');
                // Update both checkboxes if they exist
                const mainCheckbox = document.getElementById('themeCheckbox');
                const settingsCheckbox = document.getElementById('settingsThemeCheckbox');
                
                if (mainCheckbox) mainCheckbox.checked = true;
                if (settingsCheckbox) settingsCheckbox.checked = true;
                
                document.querySelector('.theme-toggle-label').textContent = '‚òÄÔ∏è';
            } else {
                document.documentElement.setAttribute('data-theme', 'light');
                // Update both checkboxes if they exist
                const mainCheckbox = document.getElementById('themeCheckbox');
                const settingsCheckbox = document.getElementById('settingsThemeCheckbox');
                
                if (mainCheckbox) mainCheckbox.checked = false;
                if (settingsCheckbox) settingsCheckbox.checked = false;
                
                document.querySelector('.theme-toggle-label').textContent = 'üåô';
            }
        }

        // Apply theme immediately
        applyTheme();

        // Toggle between light and dark mode
        function toggleTheme() {
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            localStorage.setItem('theme', currentTheme);
            applyTheme();
        }

        // Toggle theme from settings
        function toggleThemeFromSettings() {
            toggleTheme();
        }

        const initDB = async () => {
            try {
                db = await idb.openDB('inventoryDB', 4, {
                    upgrade(db, oldVersion, newVersion, transaction) {
                        console.log(`Upgrading database from version ${oldVersion} to ${newVersion}`);
                        
                        // Create object stores matching the schema in README
                        if (!db.objectStoreNames.contains('products')) {
                            const productStore = db.createObjectStore('products', { keyPath: 'id' });
                            productStore.createIndex('name', 'name', { unique: false });
                        }
                        
                    if (!db.objectStoreNames.contains('locations')) {
                            const locationStore = db.createObjectStore('locations', { keyPath: 'id' });
                            locationStore.createIndex('name', 'name', { unique: false });
                        }
                        
                    if (!db.objectStoreNames.contains('inventory')) {
                            const inventoryStore = db.createObjectStore('inventory', { keyPath: 'id', autoIncrement: false });
                            inventoryStore.createIndex('productId', 'productId', { unique: false });
                            inventoryStore.createIndex('locationId', 'locationId', { unique: false });
                            inventoryStore.createIndex('product_location', ['productId', 'locationId'], { unique: true });
                        }
                        
                        if (!db.objectStoreNames.contains('transactions')) {
                            db.createObjectStore('transactions', { keyPath: 'timestamp' });
                        }
                        
                        // Add floor plans store
                        if (!db.objectStoreNames.contains('floorPlans')) {
                            db.createObjectStore('floorPlans', { keyPath: 'locationId' });
                        }
                        
                        // Add users store
                        if (!db.objectStoreNames.contains('users')) {
                            console.log('Creating users object store');
                            db.createObjectStore('users', { keyPath: 'id' });
                        }
                    }
                });
                
                console.log('IndexedDB initialized with idb module');
                return db;
            } catch (error) {
                console.error('Error initializing database:', error);
                throw error;
            }
        };

        const saveToIndexedDB = async (storeName, data) => {
            try {
                const tx = db.transaction(storeName, 'readwrite');
                const store = tx.objectStore(storeName);
                
                await store.clear();
                for (const item of data) {
                    store.add(item); 
                }

                await tx.done; 
                console.log(`Data saved to ${storeName} successfully`);
            } catch (error) {
                console.error(`Error saving data to ${storeName}:`, error);
                throw error;
            }
        };


        const loadFromIndexedDB = async (storeName) => {
            try {
                const data = await db.getAll(storeName);
                return data;
                } catch (error) {
                console.error(`Error loading data from ${storeName}:`, error);
                throw error;
            }
        };

        const loadData = async () => {
            try {
                products = await loadFromIndexedDB('products') || [];
                locations = await loadFromIndexedDB('locations') || [];
                inventoryItems = await loadFromIndexedDB('inventory') || [];
                transactions = await loadFromIndexedDB('transactions') || [];
                
                // Try to load users, handle errors gracefully
                try {
                    users = await loadFromIndexedDB('users') || [];
                    console.log('Loaded users:', users);
                } catch (error) {
                    console.error('Error loading users:', error);
                    users = [];
                }
                
                // Set default location if empty
                if (locations.length === 0) {
                    locations = [{ id: '1', name: 'Location 1' }];
                    await saveToIndexedDB('locations', locations);
                }
                
                // Set default users if empty
                if (users.length === 0) {
                    users = [
                        { id: 'user-1', name: 'User 1' },
                        { id: 'user-2', name: 'User 2' }
                    ];
                    try {
                        await saveToIndexedDB('users', users);
                        console.log('Created default users:', users);
                    } catch (error) {
                        console.error('Error saving default users:', error);
                        // We'll continue with in-memory users even if saving fails
                    }
                }
                
                // Set current user
                if (users.length > 0) {
                    currentUser = users[0].name;
                    currentUserId = users[0].id;
                }
                
                // Add example product if no products exist
                if (products.length === 0) {
                    // Create example product
                    const exampleProduct = {
                        id: 'example-1',
                        name: 'Example Product',
                        price: 9.99,
                        comments: 'This is an example product to help you get started.',
                        barcode: '1234567890', // Example barcode
                    };
                    products.push(exampleProduct);
                    
                    // Add to inventory at default location
                    const exampleInventory = {
                        id: 'inv-example-1',
                        productId: exampleProduct.id,
                        locationId: locations[0].id,
                        quantity: 5
                    };
                    inventoryItems.push(exampleInventory);
                    
                    // Create initial transaction
                    const initialTransaction = {
                        type: 'add_inventory',
                        productId: exampleProduct.id,
                        productName: exampleProduct.name,
                        locationId: locations[0].id,
                        quantity: 5,
                        timestamp: new Date().toISOString()
                    };
                    transactions.push(initialTransaction);
                    
                    // Save the example data
                    await saveToIndexedDB('products', products);
                    await saveToIndexedDB('inventory', inventoryItems);
                    await saveToIndexedDB('transactions', transactions);
                    
                    console.log('Added example product to database');
                }
                
                // Set current location
                currentLocation = locations[0]?.id || '1';
                locationFilter = locations[0]?.id || '1';
                
                console.log('Data loaded:', {
                    products: products.length,
                    locations: locations.length,
                    inventory: inventoryItems.length,
                    transactions: transactions.length
                });
            } catch (error) {
                console.error('Error loading data:', error);
                // Set defaults
                products = [];
                locations = [{ id: '1', name: 'Location 1' }];
                inventoryItems = [];
                transactions = [];
                currentLocation = '1';
                locationFilter = '1';
            }
        };

        // Initialize database and load data
        const initializeData = async () => {
            try {
                await initDB();
                console.log('IndexedDB initialized');
                await loadData();
                
                // Initialize users dropdown
                await loadUsers();

                // Update UI
                updateLocationSelect();
                updateTable();
                updateHistory();
            } catch (error) {
                console.error('Error initializing database:', error);
                alert('Error loading data. Using default values.');
                
                // Fallback to empty data
                products = [];
                locations = [{ id: '1', name: 'Location 1' }];
                inventoryItems = [];
                transactions = [];
                currentLocation = '1';
                locationFilter = '1';
                
                // Update UI with default data
                updateLocationSelect();
                updateTable();
                updateHistory();
            }
        };

            
        async function save() {
            try {
                console.log('Saving data to IndexedDB:', {
                    products: products.length,
                    locations: locations.length,
                    inventory: inventoryItems.length,
                    transactions: transactions.length
                });
                
                // Save one store at a time to better isolate errors
                try {
                    await saveToIndexedDB('products', products);
                    console.log('Products saved successfully');
            } catch (error) {
                    console.error('Error saving products:', error);
                    alert(`Error saving products data: ${error.message || 'Unknown error'}`);
                    throw error;
                }
                
                try {
                    await saveToIndexedDB('locations', locations);
                    console.log('Locations saved successfully');
                } catch (error) {
                    console.error('Error saving locations:', error);
                    alert(`Error saving locations data: ${error.message || 'Unknown error'}`);
                    throw error;
                }
                
                try {
                    await saveToIndexedDB('inventory', inventoryItems);
                    console.log('Inventory saved successfully');
                } catch (error) {
                    console.error('Error saving inventory:', error);
                    alert(`Error saving inventory data: ${error.message || 'Unknown error'}`);
                    throw error;
                }
                
                try {
                    await saveToIndexedDB('transactions', transactions);
                    console.log('Transactions saved successfully');
                } catch (error) {
                    console.error('Error saving transactions:', error);
                    alert(`Error saving transactions data: ${error.message || 'Unknown error'}`);
                    throw error;
                }
                
                console.log('All data saved successfully');
            } catch (error) {
                console.error('Error in saveToLocalStorage:', error);
                alert('Error saving data. Please check console for details.');
            }
        }

        function updateLocationSelect() {
            // If no location is selected, select the first one
            if (!currentLocation && locations.length > 0) {
                currentLocation = locations[0].id;
            }
            // If no location filter is set, set it to current location
            if (!locationFilter && locations.length > 0) {
                locationFilter = currentLocation || locations[0].id;
            }
            renderLocationFilterButtons();
        }

        function changeLocation(selectedLocationId) {
            if (!selectedLocationId && locations.length > 0) {
                // If somehow no location is selected, select the first one
                selectedLocationId = locations[0].id;
            }
            currentLocation = selectedLocationId;
            locationFilter = selectedLocationId;
            renderLocationFilterButtons();
            updateTable();
            updateHistory();
        }

        async function renameLocation() {
            const newName = document.getElementById('locationName').value.trim();
            if (!newName) {
                alert('Location name cannot be empty');
                const currentLoc = locations.find(loc => loc.id === currentLocation);
                document.getElementById('locationName').value = currentLoc ? currentLoc.name : '';
                return;
            }

            const locationIndex = locations.findIndex(loc => loc.id === currentLocation);
            if (locationIndex !== -1) {
                const oldName = locations[locationIndex].name;
                locations[locationIndex].name = newName;
            
            await addToHistory({
                type: 'rename_location',
                    locationId: currentLocation,
                oldName: oldName,
                newName: newName,
                timestamp: new Date().toISOString()
            });

                await save();
            updateLocationSelect();
            renderLocationFilterButtons();
            }
        }

        async function addLocation() {
            const newLocationId = String(Date.now());
            const newLocation = {
                id: newLocationId,
                name: `Location ${locations.length + 1}`
            };
            
            locations.push(newLocation);
            currentLocation = newLocationId;
            locationFilter = newLocationId;
            
            await addToHistory({
                type: 'add_location',
                location: newLocation,
                timestamp: new Date().toISOString()
            });
            
            await save();
            updateLocationSelect();
            renderLocationFilterButtons();
            updateTable();
            updateHistory();
        }

        async function deleteLocation() {
            if (locations.length <= 1) {
                alert('Cannot delete the last location');
                return;
            }
            
            if (confirm('Are you sure you want to delete this location? All inventory items in this location will be deleted.')) {
                // Remove inventory items for this location
                inventoryItems = inventoryItems.filter(item => item.locationId !== currentLocation);
                
                // Remove the location
                const locationIndex = locations.findIndex(loc => loc.id === currentLocation);
                const deletedLocation = locations[locationIndex];
                locations.splice(locationIndex, 1);
                
                // Update current location to first available
                currentLocation = locations[0].id;
                locationFilter = locations[0].id;
                
                await addToHistory({
                    type: 'delete_location',
                    location: deletedLocation,
                    timestamp: new Date().toISOString()
                });
                
                            await save();
            updateLocationSelect();
            renderLocationFilterButtons();
            updateTable();
            updateHistory();
            }
        }

        async function addItem() {
            const nameInput = document.getElementById('itemName').value.trim();
            const quantityInput = document.getElementById('itemQuantity').value;
            let price = parseFloat(document.getElementById('itemPrice').value);
            const locationId = locationFilter || currentLocation;

            // Regex to match codes like 4b1123, 4B1123, 4B 1123, etc.
            const codeRegex = /([0-9]+)[bB]\s*([0-9]{1,2})([0-9]{2})/g;
            let match;
            let codes = [];
            let nameBase = nameInput;
            // Find all codes and remove them from the name
            nameBase = nameBase.replace(/(\s*[0-9]+[bB]\s*[0-9]{1,2}[0-9]{2})+/g, '').trim();
            codeRegex.lastIndex = 0;
            while ((match = codeRegex.exec(nameInput)) !== null) {
                codes.push({
                    quantity: parseInt(match[1]),
                    month: match[2].padStart(2, '0'),
                    year: match[3],
                });
            }

            if (codes.length > 0) {
                // If price is empty or invalid, set to 0
                if (isNaN(price)) price = 0;
                // Add a product for each code
                for (const code of codes) {
                    const prodName = `${code.year}-${code.month} ${nameBase}`;
                    const quantity = code.quantity;
                    if (!prodName || isNaN(quantity) || quantity < 0 || price < 0) {
                        alert(t('Please fill all fields with valid values'));
                        continue;
                    }
                    let product = products.find(p => p.name.toLowerCase() === prodName.toLowerCase());
                    if (!product) {
                        product = {
                            id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                            name: prodName,
                            price,
                            comments: '',
                            barcode: '',
                        };
                        products.push(product);
                    }
                    let inventoryEntry = inventoryItems.find(item =>
                        item.productId === product.id && item.locationId === locationId
                    );
                    if (inventoryEntry) {
                        const oldQuantity = inventoryEntry.quantity;
                        inventoryEntry.quantity += quantity;
                        await addToHistory({
                            type: 'update_quantity',
                            productId: product.id,
                            productName: product.name,
                            locationId: locationId,
                            oldQuantity,
                            newQuantity: inventoryEntry.quantity,
                            timestamp: new Date().toISOString()
                        });
                    } else {
                        inventoryEntry = {
                            id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                            productId: product.id,
                            locationId: locationId,
                            quantity
                        };
                        inventoryItems.push(inventoryEntry);
                        await addToHistory({
                            type: 'add_inventory',
                            productId: product.id,
                            productName: product.name,
                            locationId: locationId,
                            quantity,
                            timestamp: new Date().toISOString()
                        });
                    }
                }
                await save();
                updateTable();
                clearForm();
                return;
            }

            // Fallback to default logic if no codes found
            const name = nameInput;
            const quantity = parseInt(quantityInput);
            if (!name || isNaN(quantity) || isNaN(price) || quantity < 0 || price < 0) {
                alert(t('Please fill all fields with valid values'));
                return;
            }
            let product = products.find(p => p.name.toLowerCase() === name.toLowerCase());
            if (!product) {
                product = {
                    id: Date.now().toString(),
                    name,
                    price,
                    comments: '',
                    barcode: '',
                };
                products.push(product);
            }
            let inventoryEntry = inventoryItems.find(item =>
                item.productId === product.id && item.locationId === locationId
            );
            if (inventoryEntry) {
                const oldQuantity = inventoryEntry.quantity;
                inventoryEntry.quantity += quantity;
                await addToHistory({
                    type: 'update_quantity',
                    productId: product.id,
                    productName: product.name,
                    locationId: locationId,
                    oldQuantity,
                    newQuantity: inventoryEntry.quantity,
                    timestamp: new Date().toISOString()
                });
            } else {
                inventoryEntry = {
                    id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                    productId: product.id,
                    locationId: locationId,
                    quantity
                };
                inventoryItems.push(inventoryEntry);
                await addToHistory({
                    type: 'add_inventory',
                    productId: product.id,
                    productName: product.name,
                    locationId: locationId,
                    quantity,
                    timestamp: new Date().toISOString()
                });
            }
            await save();
            updateTable();
            clearForm();
        }

        async function deleteItem(productId) {
            const product = products.find(p => p.id === productId);
            if (!product) return;
            
            if (confirm(`Are you sure you want to delete "${product.name}" from all locations?`)) {
                // Get all inventory entries for this product
                const affectedEntries = inventoryItems.filter(item => item.productId === productId);
                
                // Record each deletion in history
                for (const entry of affectedEntries) {
                    const locationName = locations.find(loc => loc.id === entry.locationId)?.name || 'Unknown';
                    
                await addToHistory({
                        type: 'delete_inventory',
                        productId,
                        productName: product.name,
                        locationId: entry.locationId,
                        locationName,
                        quantity: entry.quantity,
                    timestamp: new Date().toISOString()
                });
                }
                
                // Remove all inventory entries for this product
                inventoryItems = inventoryItems.filter(item => item.productId !== productId);
                
                // Remove the product completely
                products = products.filter(p => p.id !== productId);
                
                await addToHistory({
                    type: 'delete_product',
                    productId,
                    productName: product.name,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateTable();
            }
        }

        async function editField(productId, field, element) {
            // Prevent re-entering edit mode if already editing
            if (element.querySelector('input')) {
                // Already editing, do nothing
                return;
            }
            const product = products.find(p => p.id === productId);
            if (!product) return;

            const currentValue = element.textContent;
            const input = document.createElement('input');
            input.type = field === 'price' ? 'number' : field === 'quantity' ? 'number' : 'text';
            input.step = field === 'price' ? '0.01' : '1';
            input.min = field === 'quantity' || field === 'price' ? '0' : '';
            input.value = currentValue;
            input.className = 'editable editing';
            
            element.textContent = '';
            element.appendChild(input);
            input.focus();

            async function saveEdit() {
                const newValue = input.value;
                if (newValue === currentValue) {
                    element.textContent = currentValue;
                    return;
                }
                
                if (field === 'price') {
                    const newPrice = parseFloat(newValue);
                    if (!isNaN(newPrice) && newPrice >= 0) {
                        const oldPrice = product.price;
                        product.price = newPrice;
                        
                        await addToHistory({
                            type: 'edit_product',
                            productId: product.id,
                            productName: product.name,
                            field: 'price',
                            oldValue: oldPrice,
                            newValue: newPrice,
                            timestamp: new Date().toISOString()
                        });
                        
                        await save();
                        updateTable();
                    } else {
                        element.textContent = currentValue;
                        return;
                    }
                } else if (field === 'name') {
                    const newName = newValue.trim();
                    if (newName) {
                        const oldName = product.name;
                        product.name = newName;
                        
                        await addToHistory({
                            type: 'edit_product',
                            productId: product.id,
                            productName: newName,
                            field: 'name',
                            oldValue: oldName,
                            newValue: newName,
                            timestamp: new Date().toISOString()
                        });
                        
                        await save();
                        updateTable();
                    } else {
                        element.textContent = currentValue;
                        return;
                    }
                } else if (field === 'quantity') {
                    const newQuantity = parseInt(newValue);
                    if (!isNaN(newQuantity) && newQuantity >= 0) {
                        // Find inventory entry for this product and location
                        let inventoryEntry = inventoryItems.find(item => 
                            item.productId === productId && item.locationId === currentLocation
                        );
                        
                        if (inventoryEntry) {
                            const oldQuantity = inventoryEntry.quantity;
                            inventoryEntry.quantity = newQuantity;
                            
                            await addToHistory({
                                type: 'update_quantity',
                                productId: product.id,
                                productName: product.name,
                                locationId: currentLocation,
                                oldQuantity,
                                newQuantity,
                                timestamp: new Date().toISOString()
                            });
                        } else if (newQuantity > 0) {
                            // Create new inventory entry
                            inventoryEntry = {
                                id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                                productId: product.id,
                                locationId: currentLocation,
                                quantity: newQuantity
                            };
                            
                            inventoryItems.push(inventoryEntry);
                            
                            await addToHistory({
                                type: 'add_inventory',
                                productId: product.id,
                                productName: product.name,
                                locationId: currentLocation,
                                quantity: newQuantity,
                                timestamp: new Date().toISOString()
                            });
                        }
                        
                        await save();
                        updateTable();
                    } else {
                        element.textContent = currentValue;
                        return;
                    }
                }
            }

            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                    input.blur();
                }
            });
        }

        function toggleDetails(event, id) {
            const details = document.getElementById(`details-${id}`);
            const button = event.target;
            if (details.classList.contains('show')) {
                details.classList.remove('show');
                button.textContent = '‚ñº';
            } else {
                details.classList.add('show');
                button.textContent = '‚ñ≤';
            }
        }

        async function updateComments(productId) {
            const product = products.find(p => p.id === productId);
            if (!product) return;

            const newComments = document.getElementById(`comments-${productId}`).value;
            
            if (product.comments !== newComments) {
                const oldComments = product.comments || '';
                product.comments = newComments;

                await addToHistory({
                    type: 'update_comments',
                    productId: product.id,
                    productName: product.name,
                    oldValue: oldComments,
                    newValue: newComments,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateTable();
            }
        }

        async function changeQuantity(productId, change) {
            const product = products.find(item => item.id === productId);
            if (!product) return;
            
            // Find inventory entry for this product and location
            let inventoryEntry = inventoryItems.find(item => 
                item.productId === productId && item.locationId === currentLocation
            );
            
            if (inventoryEntry) {
                // Update existing entry
                const oldQuantity = inventoryEntry.quantity;
                const newQuantity = oldQuantity + change;
                
                if (newQuantity >= 0) {
                    inventoryEntry.quantity = newQuantity;
                    
                    await addToHistory({
                        type: 'update_quantity',
                        productId: product.id,
                        productName: product.name,
                        locationId: currentLocation,
                        oldQuantity,
                        newQuantity,
                        timestamp: new Date().toISOString()
                    });
                    
                    await save();
                    updateTable();
                }
            } else if (change > 0) {
                // Create new inventory entry
                inventoryEntry = {
                    id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                    productId: product.id,
                    locationId: currentLocation,
                    quantity: change
                };
                
                inventoryItems.push(inventoryEntry);
                
                await addToHistory({
                    type: 'add_inventory',
                    productId: product.id,
                    productName: product.name,
                    locationId: currentLocation,
                    quantity: change,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateTable();
            }
        }

        // Allow direct editing of location quantity by clicking on the value
        async function editLocationQuantity(productId, locationId, element) {
            const product = products.find(p => p.id === productId);
            if (!product) return;

            const currentValue = element.textContent;
            const input = document.createElement('input');
            input.type = 'number';
            input.step = '1';
            input.min = '0';
            input.value = currentValue;
            input.className = 'quantity-value editing';
            input.style.width = '40px';
            
            element.textContent = '';
            element.appendChild(input);
            input.focus();

            async function saveEdit() {
                const newValue = parseInt(input.value);
                const oldValue = parseInt(currentValue);
                
                if (isNaN(newValue) || newValue === oldValue) {
                    element.textContent = currentValue;
                    return;
                }
                
                if (newValue >= 0) {
                    // Find inventory entry for this product and location
                    let inventoryEntry = inventoryItems.find(item => 
                        item.productId === productId && item.locationId === locationId
                    );
                    
                    if (inventoryEntry) {
                        inventoryEntry.quantity = newValue;
                        
                        await addToHistory({
                            type: 'update_quantity',
                            productId: product.id,
                            productName: product.name,
                            locationId: locationId,
                            oldQuantity: oldValue,
                            newQuantity: newValue,
                            timestamp: new Date().toISOString()
                        });
                    } else if (newValue > 0) {
                        // Create new inventory entry
                        inventoryEntry = {
                            id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                            productId: product.id,
                            locationId: locationId,
                            quantity: newValue
                        };
                        
                        inventoryItems.push(inventoryEntry);
                        
                        await addToHistory({
                            type: 'add_inventory',
                            productId: product.id,
                            productName: product.name,
                            locationId: locationId,
                            quantity: newValue,
                            timestamp: new Date().toISOString()
                        });
                    }
                    
                    await save();
                    updateTable();
                } else {
                    element.textContent = currentValue;
                }
            }

            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                    input.blur();
                }
            });
        }

        // Debounce function to limit how often a function can be called
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        }
        
        // Store pending changes to show immediate visual feedback
        const pendingQuantityChanges = {};
        
        // Apply visual update immediately without saving
        function applyVisualQuantityChange(productId, locationId, change) {
            const key = `${productId}-${locationId}`;
            pendingQuantityChanges[key] = (pendingQuantityChanges[key] || 0) + change;
            
            // Find the quantity display element and update it
            const quantityElement = document.querySelector(`[data-product-id="${productId}"][data-location-id="${locationId}"]`);
            if (quantityElement) {
                const currentQuantity = parseInt(quantityElement.textContent || '0');
                const newQuantity = Math.max(0, currentQuantity + change);
                quantityElement.textContent = newQuantity;
            }
            
            // Update total if needed
            const totalElement = document.querySelector(`[data-product-id="${productId}"][data-total="true"]`);
            if (totalElement) {
                const currentTotal = parseInt(totalElement.textContent.replace('Total: ', '') || '0');
                const newTotal = Math.max(0, currentTotal + change);
                totalElement.textContent = `Total: ${newTotal}`;
            }
        }

        // Debounced function to actually save changes
        const saveQuantityChange = debounce(async (productId, locationId, change) => {
            const key = `${productId}-${locationId}`;
            const totalChange = pendingQuantityChanges[key] || 0;
            
            // Reset pending changes
            pendingQuantityChanges[key] = 0;
            
            if (totalChange === 0) return;
            
            const product = products.find(item => item.id === productId);
            if (!product) return;
            
            // Find inventory entry for this product and the specified location
            let inventoryEntry = inventoryItems.find(item => 
                item.productId === productId && item.locationId === locationId
            );
            
            if (inventoryEntry) {
                // Update existing entry
                const oldQuantity = inventoryEntry.quantity;
                const newQuantity = Math.max(0, oldQuantity + totalChange);
                
                inventoryEntry.quantity = newQuantity;
                
                await addToHistory({
                    type: 'update_quantity',
                    productId: product.id,
                    productName: product.name,
                    locationId: locationId,
                    oldQuantity,
                    newQuantity,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateTable();
            } else if (totalChange > 0) {
                // Create new inventory entry
                inventoryEntry = {
                    id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                    productId: product.id,
                    locationId: locationId,
                    quantity: totalChange
                };
                
                inventoryItems.push(inventoryEntry);
                
                await addToHistory({
                    type: 'add_inventory',
                    productId: product.id,
                    productName: product.name,
                    locationId: locationId,
                    quantity: totalChange,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateTable();
            }
        }, 500); // 500ms debounce time
        
        // Function to change quantity with debounce
        function changeSpecificLocationQuantityWithDebounce(productId, locationId, change) {
            // Apply visual change immediately
            applyVisualQuantityChange(productId, locationId, change);
            
            // Schedule the actual save after debounce
            saveQuantityChange(productId, locationId, change);
        }

        function clearForm() {
            document.getElementById('itemName').value = '';
            document.getElementById('itemQuantity').value = '';
            document.getElementById('itemPrice').value = '';
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${day}-${month}-${year} ${hours}:${minutes}`;
        }

        function updateHistory() {
            const historyList = document.getElementById('historyList');
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            historyList.innerHTML = '';
            
            if (!Array.isArray(transactions)) {
                console.warn('Transactions is not an array:', transactions);
                return;
            }
            
            // Sort transactions by timestamp (newest first)
            const sortedTransactions = [...transactions].sort((a, b) => 
                new Date(b.timestamp) - new Date(a.timestamp)
            );
            
            // Filter transactions by search term and location filter
            let filteredTransactions = sortedTransactions;
            
            // Apply location filter if set
            if (locationFilter) {
                filteredTransactions = filteredTransactions.filter(transaction => {
                    // Include transactions that have a locationId matching the current filter
                    if (transaction.locationId === locationFilter) {
                        return true;
                    }
                    // Include location-related transactions (add_location, delete_location, rename_location)
                    if (transaction.type === 'add_location' || transaction.type === 'delete_location' || transaction.type === 'rename_location') {
                        return true;
                    }
                    // Include transactions without locationId (like product creation, etc.)
                    if (!transaction.locationId) {
                        return true;
                    }
                    return false;
                });
            }
            
            // Apply search term filter if provided
            if (searchTerm) {
                filteredTransactions = filteredTransactions.filter(transaction => 
                    (transaction.productName && transaction.productName.toLowerCase().includes(searchTerm)) || 
                    (transaction.productId && products.some(p => 
                        p.id === transaction.productId && 
                        p.name.toLowerCase().includes(searchTerm)
                    ))
                );
            }
            
            // Pagination logic
            const totalHistory = filteredTransactions.length;
            const totalHistoryPages = Math.ceil(totalHistory / historyPageSize) || 1;
            if (historyPage > totalHistoryPages) historyPage = 1;
            const paginatedHistory = filteredTransactions.slice((historyPage - 1) * historyPageSize, historyPage * historyPageSize);
            
            paginatedHistory.forEach((transaction, index) => {
                const div = document.createElement('div');
                div.className = 'history-item';
                let changeText = '';
                
                try {
                    // Get location name if locationId exists
                    const getLocationName = (locationId) => {
                        const location = locations.find(loc => loc.id === locationId);
                        return location ? location.name : 'Unknown Location';
                    };
                    
                    switch (transaction.type) {
                        case 'add_inventory':
                            changeText = t('log_add_inventory')
                                .replace('{user}', transaction.user)
                                .replace('{quantity}', transaction.quantity)
                                .replace('{productName}', transaction.productName)
                                .replace('{locationName}', getLocationName(transaction.locationId));
                            break;
                        case 'delete_inventory':
                            const locationDisplayName = transaction.locationName || getLocationName(transaction.locationId);
                            changeText = t('log_delete_inventory')
                                .replace('{user}', transaction.user)
                                .replace('{productName}', transaction.productName)
                                .replace('{locationName}', locationDisplayName);
                            break;
                        case 'delete_product':
                            changeText = t('log_delete_product')
                                .replace('{user}', transaction.user)
                                .replace('{productName}', transaction.productName);
                            break;
                        case 'update_quantity':
                            changeText = t('log_update_quantity')
                                .replace('{user}', transaction.user)
                                .replace('{productName}', transaction.productName)
                                .replace('{oldQuantity}', transaction.oldQuantity)
                                .replace('{newQuantity}', transaction.newQuantity)
                                .replace('{locationName}', getLocationName(transaction.locationId));
                            break;
                        case 'edit_product':
                            changeText = t('log_edit_product')
                                .replace('{user}', transaction.user)
                                .replace('{field}', transaction.field)
                                .replace('{productName}', transaction.productName)
                                .replace('{oldValue}', transaction.oldValue)
                                .replace('{newValue}', transaction.newValue);
                            break;
                        case 'update_details':
                            changeText = t('log_update_details')
                                .replace('{user}', transaction.user)
                                .replace('{productName}', transaction.productName);
                            break;
                        case 'add_location':
                            changeText = t('log_add_location')
                                .replace('{user}', transaction.user)
                                .replace('{locationName}', transaction.location?.name || '');
                            break;
                        case 'delete_location':
                            changeText = t('log_delete_location')
                                .replace('{user}', transaction.user)
                                .replace('{locationName}', transaction.location?.name || '');
                            break;
                        case 'rename_location':
                            changeText = t('log_rename_location')
                                .replace('{user}', transaction.user)
                                .replace('{oldName}', transaction.oldName)
                                .replace('{newName}', transaction.newName);
                            break;
                        case 'update_comments':
                            changeText = t('log_update_comments')
                                .replace('{user}', transaction.user)
                                .replace('{productName}', transaction.productName);
                            break;
                        case 'scan_barcode':
                            changeText = t('log_scan_barcode')
                                .replace('{user}', transaction.user)
                                .replace('{barcode}', transaction.barcode)
                                .replace('{productName}', transaction.productName || '');
                            break;
                        case 'assign_barcode':
                            changeText = t('log_assign_barcode')
                                .replace('{user}', transaction.user)
                                .replace('{newValue}', transaction.newValue)
                                .replace('{productName}', transaction.productName);
                            break;
                        case 'remove_barcode':
                            changeText = t('log_remove_barcode')
                                .replace('{user}', transaction.user)
                                .replace('{productName}', transaction.productName);
                            break;
                        case 'create_product':
                            changeText = t('log_create_product')
                                .replace('{user}', transaction.user)
                                .replace('{productName}', transaction.productName)
                                .replace('{barcode}', transaction.barcode || '');
                            break;
                        default:
                            changeText = t('log_unknown')
                                .replace('{user}', transaction.user)
                                .replace('{type}', transaction.type);
                    }
                } catch (error) {
                    console.error('Error processing transaction entry:', error, transaction);
                    changeText = t('log_error');
                }

                div.innerHTML = `
                    <span>${changeText} - ${formatDate(transaction.timestamp)}</span>
                `;
                historyList.appendChild(div);
            });
            
            // Show a message if no matching transactions
            if (searchTerm && filteredTransactions.length === 0) {
                const noResults = document.createElement('div');
                noResults.className = 'no-results';
                noResults.textContent = t('No matching history items found.');
                historyList.appendChild(noResults);
            }
            // Render pagination controls
            renderPaginationControls(
                'historyPagination',
                historyPage,
                totalHistoryPages,
                historyPageSize,
                (page) => { historyPage = page; updateHistory(); },
                (size) => { historyPageSize = size; historyPage = 1; updateHistory(); }
            );
        }

        async function addToHistory(change) {
            // Add user information to the change record
            change.user = currentUser;
            change.userId = currentUserId;
            transactions.push(change);
            await save();
            updateHistory();
        }

        document.getElementById('searchInput').addEventListener('input', function() {
            inventoryPage = 1;
            historyPage = 1;
            updateTable();
            updateHistory(); // Also update history when search input changes
            renderLocationFilterButtons(); // Update location filter buttons with new quantities
        });
                // --- Sorting State ---
                let sortColumn = 'name';
        let sortDirection = 'asc'; // 'asc' or 'desc'

        function setSort(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'asc';
            }
            updateTable();
        }

        function updateSortIcons() {
            const icons = {
                name: document.getElementById('sortIconName'),
                quantity: document.getElementById('sortIconQuantity'),
                price: document.getElementById('sortIconPrice')
            };
            Object.keys(icons).forEach(col => {
                if (sortColumn === col) {
                    icons[col].textContent = sortDirection === 'asc' ? '‚ñ≤' : '‚ñº';
                } else {
                    icons[col].textContent = '';
                }
            });
        }

        // Initial load
        updateLocationSelect();
        updateTable();
        updateHistory();

        function updateTable() {
            const tbody = document.getElementById('inventoryBody');
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            tbody.innerHTML = '';
            // Get products with inventory in any location (for total quantities)
            const productInventory = {};
            // Initialize with all products
            products.forEach(product => {
                productInventory[product.id] = {
                    product,
                    quantities: {},
                    totalQuantity: 0
                };
            });
            // Add quantities from inventory
            inventoryItems.forEach(item => {
                if (productInventory[item.productId]) {
                    productInventory[item.productId].quantities[item.locationId] = item.quantity;
                    productInventory[item.productId].totalQuantity += item.quantity;
                }
            });
            // Filter by search term and locationFilter
            const filteredProducts = Object.values(productInventory).filter(entry => {
                const product = entry.product;
                const matchesName = product.name.toLowerCase().includes(searchTerm);
                const matchesBarcode = product.barcode && product.barcode.toLowerCase().includes(searchTerm);
                // Only show if product has quantity in selected location
                const showInLocation = locationFilter ? (entry.quantities[locationFilter] > 0) : true;
                return (matchesName || matchesBarcode) && showInLocation;
            });
            // --- Sum total quantities for filtered products ---
            // If a location filter is active, sum only that location's quantities
            // Otherwise, sum the total quantities across all locations
            const totalFound = filteredProducts.reduce((sum, entry) => {
                if (locationFilter) {
                    return sum + (entry.quantities[locationFilter] || 0);
                }
                return sum + entry.totalQuantity;
            }, 0);
            const totalFoundContainer = document.getElementById('totalFoundContainer');
            if (totalFoundContainer) {
                totalFoundContainer.textContent = `Total found: ${totalFound}`;
            }
            // --- Sort by selected column and direction ---
            filteredProducts.sort((a, b) => {
                let valA, valB;
                if (sortColumn === 'name') {
                    valA = a.product.name.toLowerCase();
                    valB = b.product.name.toLowerCase();
                } else if (sortColumn === 'quantity') {
                    valA = a.totalQuantity;
                    valB = b.totalQuantity;
                } else if (sortColumn === 'price') {
                    valA = a.product.price;
                    valB = b.product.price;
                }
                if (valA < valB) return sortDirection === 'asc' ? -1 : 1;
                if (valA > valB) return sortDirection === 'asc' ? 1 : -1;
                return 0;
            });
            // Pagination logic
            const totalProducts = filteredProducts.length;
            const totalInventoryPages = Math.ceil(totalProducts / inventoryPageSize) || 1;
            if (inventoryPage > totalInventoryPages) inventoryPage = 1;
            const paginatedProducts = filteredProducts.slice((inventoryPage - 1) * inventoryPageSize, inventoryPage * inventoryPageSize);
            // Update sort icons
            updateSortIcons();
            // Display the products
            paginatedProducts.forEach(entry => {
                const product = entry.product;
                const currentLocationQuantity = entry.quantities[currentLocation] || 0;
                
                const tr = document.createElement('tr');
                tr.className = 'item-row';
                tr.dataset.productId = product.id;
                
                // When a location filter is active, only show that location's quantities
                const displayedLocations = locationFilter ? locations.filter(loc => loc.id === locationFilter) : locations;
                const quantityHeaderText = locationFilter
                    ? `${(locations.find(l => l.id === locationFilter) || { name: 'Quantity' }).name}: ${entry.quantities[locationFilter] || 0}`
                    : `Total: ${entry.totalQuantity}`;

                const locationQuantities = locations.map(loc => {
                    const quantity = entry.quantities[loc.id] || 0;
                    const isCurrent = loc.id === currentLocation;
                    return quantity > 0 ? 
                        `<span class="location-quantity ${isCurrent ? 'current' : ''}">${loc.name}: ${quantity}</span>` : 
                        '';
                }).filter(Boolean).join('');

                const detailsHtml = `
                    <div class="item-details" id="details-${product.id}">
                        <div class="item-details-grid">
                            <div class="item-details-section">
                                <label>Comments:</label>
                                <textarea id="comments-${product.id}" onblur="updateComments('${product.id}')">${product.comments || ''}</textarea>
                            </div>
                        </div>
                    </div>
                `;

                tr.innerHTML = `
                    <td>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span class="editable" onclick="if(!this.querySelector('input'))editField('${product.id}', 'name', this)">${product.name}</span>
                            <button class="toggle-details-btn" onclick="toggleDetails(event, '${product.id}')">‚ñº</button>
                            <button class="search-name-btn" title="Search for this name" onclick="searchByName('${product.name.replace(/'/g, "\\'")}')" style="background: none; border: none; cursor: pointer; padding: 0; margin-left: 2px;">
                                <span style="font-size: 1em;">üîç</span>
                            </button>
                        </div>
                    </td>
                    <td>
                        <div class="total-quantity">
                            <strong data-product-id="${product.id}" data-total="true">${quantityHeaderText}</strong>
                        </div>
                        <div class="location-quantities-list">
                            ${displayedLocations.map(loc => {
                                const locQuantity = entry.quantities[loc.id] || 0;
                                const isCurrent = loc.id === currentLocation;
                                return `
                                <div class="location-quantity-item ${isCurrent ? 'current' : ''}">
                                    <span class="location-name">${loc.name}:</span>
                                    <div class="quantity-controls">
                                        <button onclick="changeSpecificLocationQuantityWithDebounce('${product.id}', '${loc.id}', -1)" class="quantity-btn">-</button>
                                        <span class="quantity-value" data-product-id="${product.id}" data-location-id="${loc.id}" onclick="editLocationQuantity('${product.id}', '${loc.id}', this)">${locQuantity}</span>
                                        <button onclick="changeSpecificLocationQuantityWithDebounce('${product.id}', '${loc.id}', 1)" class="quantity-btn">+</button>
                                    </div>
                                </div>
                                `;
                            }).join('')}
                        </div>
                    </td>
                    <td>
                        <span class="editable" onclick="if(!this.querySelector('input'))editField('${product.id}', 'price', this)">${product.price.toFixed(2)}</span>
                    </td>
                    <td>
                        <button onclick="deleteItem('${product.id}')">Delete</button>
                        <button class="barcode-btn" onclick="openBarcodeModal('${product.id}')">${product.barcode ? 'Edit Barcode' : 'Add Barcode'}</button>
                    </td>
                `;
                tbody.appendChild(tr);

                // Add details row
                const detailsRow = document.createElement('tr');
                detailsRow.className = 'item-details-row';
                detailsRow.innerHTML = `
                    <td colspan="4">
                        ${detailsHtml}
                    </td>
                `;
                tbody.appendChild(detailsRow);
            });
            // Render pagination controls
            renderPaginationControls(
                'inventoryPagination',
                inventoryPage,
                totalInventoryPages,
                inventoryPageSize,
                (page) => { inventoryPage = page; updateTable(); },
                (size) => { inventoryPageSize = size; inventoryPage = 1; updateTable(); }
            );
            
            // Update location filter buttons to reflect current quantities
            renderLocationFilterButtons();
        }

        // Handle errors with IndexedDB
        const handleDBError = (error) => {
            console.error('IndexedDB error:', error.message);
            alert(`Database error: ${error.message}. Some features may not work correctly.`);
        };

        // Add global event handler for IndexedDB errors
        window.addEventListener('error', (event) => {
            if (event.target && event.target.error && event.target.error.name && 
                event.target.error.name.includes('IDB')) {
                handleDBError(event.target.error);
            }
        });

        // Initialize the app when DOM content is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize with error handling
            initializeData().catch(error => {
                console.error('Error during initialization:', error);
                alert('Failed to initialize the application. Please refresh the page or check console for details.');
            });
            // Set initial filter and current location
            setTimeout(() => {
                if (locations && locations.length > 0) {
                    currentLocation = locations[0].id;
                    locationFilter = locations[0].id;
                    renderLocationFilterButtons();
                    updateTable();
                }
            }, 500);
        });

        
        function changeUser(selectedUserId) {
            if (!selectedUserId && users.length > 0) {
                // If somehow no user is selected, select the first one
                selectedUserId = users[0].id;
                document.getElementById('userSelect').value = selectedUserId;
            }
            currentUserId = selectedUserId;
            currentUser = users.find(user => user.id === selectedUserId)?.name || '';
            // Ensure location filter is maintained when changing users
            if (!locationFilter && locations.length > 0) {
                locationFilter = currentLocation || locations[0].id;
            }
            updateTable();
            updateHistory();
        }
        
        async function renameUser() {
            const userSelect = document.getElementById('userSelect');
            const selectedUserName = userSelect.value;
            const selectedUser = users.find(user => user.name === selectedUserName);
            
            if (!selectedUser) return;
            
            const newName = prompt("Enter new name for " + selectedUserName + ":", selectedUserName);
            
            if (newName && newName.trim() !== "") {
                // Update option text
                const selectedOption = userSelect.options[userSelect.selectedIndex];
                selectedOption.text = newName;
                selectedOption.value = newName;
                
                // Update in users array
                selectedUser.name = newName;
                
                // Update current user
                currentUser = newName;
                
                // Update in history
                updateUserInHistory(selectedUserName, newName);
                
                // Save to IndexedDB
                await saveToIndexedDB('users', users);
                
                console.log('User renamed from', selectedUserName, 'to', newName);
            }
        }
        
        async function addUser() {
            const userSelect = document.getElementById('userSelect');
            const newName = prompt("Enter name for new user:", "");
            
            if (newName && newName.trim() !== "") {
                // Create new user object
                const newUser = {
                    id: 'user-' + Date.now(),
                    name: newName
                };
                
                // Add to users array
                users.push(newUser);
                
                // Create new option
                const option = document.createElement('option');
                option.text = newName;
                option.value = newName;
                userSelect.add(option);
                
                // Select the new user
                userSelect.value = newName;
                currentUser = newName;
                currentUserId = newUser.id;
                
                // Ensure location filter is maintained
                if (!locationFilter && locations.length > 0) {
                    locationFilter = currentLocation || locations[0].id;
                }
                
                // Save to IndexedDB
                await saveToIndexedDB('users', users);
                
                console.log('New user added:', newName, '(ID:', newUser.id, ')');
            }
        }
        
        async function deleteUser() {
            const userSelect = document.getElementById('userSelect');
            
            // Prevent deleting if only one user remains
            if (userSelect.options.length <= 1) {
                alert("Cannot delete the last user.");
                return;
            }
            
            const selectedUserName = userSelect.value;
            const userIndex = users.findIndex(user => user.name === selectedUserName);
            
            if (userIndex === -1) return;
            
            if (confirm("Are you sure you want to delete user: " + selectedUserName + "?")) {
                // Remove from users array
                users.splice(userIndex, 1);
                
                // Remove the selected option
                userSelect.remove(userSelect.selectedIndex);
                
                // Update current user to the first available
                currentUser = userSelect.value;
                const newSelectedUser = users.find(user => user.name === currentUser);
                if (newSelectedUser) {
                    currentUserId = newSelectedUser.id;
                }
                
                // Ensure location filter is maintained
                if (!locationFilter && locations.length > 0) {
                    locationFilter = currentLocation || locations[0].id;
                }
                
                // Save to IndexedDB
                await saveToIndexedDB('users', users);
                
                console.log('User deleted:', selectedUserName);
            }
        }
        
        function updateUserInHistory(oldName, newName) {
            // Update username in transaction history
            for (const transaction of transactions) {
                if (transaction.user === oldName) {
                    transaction.user = newName;
                }
            }
            
            // Update the display
            updateHistory();
            
            // Save changes
            save();
        }
        
        async function loadUsers() {
            try {
                users = await loadFromIndexedDB('users') || [];
                const userSelect = document.getElementById('userSelect');
                
                // Only update the user selector if it exists
                if (userSelect) {
                    userSelect.innerHTML = '';
                    users.forEach(user => {
                        const option = document.createElement('option');
                        option.value = user.id;
                        option.textContent = user.name;
                        if (user.id === currentUserId) {
                            option.selected = true;
                        }
                        userSelect.appendChild(option);
                    });

                    // If no user is selected, select the first one
                    if (!currentUserId && users.length > 0) {
                        currentUserId = users[0].id;
                        currentUser = users[0].name;
                        userSelect.value = currentUserId;
                    }
                    
                    // Ensure location filter is set
                    if (!locationFilter && locations.length > 0) {
                        locationFilter = locations[0].id;
                    }
                }
                
                // Update the table to reflect any user changes
                updateTable();
            } catch (error) {
                console.error('Error loading users:', error);
            }
        }

        // Export/Import Functions
        async function exportData() {
            try {
                // Collect all data from IndexedDB
                const exportData = {
                    products: await loadFromIndexedDB('products') || [],
                    locations: await loadFromIndexedDB('locations') || [],
                    inventory: await loadFromIndexedDB('inventory') || [],
                    transactions: await loadFromIndexedDB('transactions') || [],
                    users: await loadFromIndexedDB('users') || [],
                    floorPlans: await loadFromIndexedDB('floorPlans') || [],
                    exportDate: new Date().toISOString(),
                    appVersion: '1.0.0'
                };
                
                // Convert to JSON string
                const jsonData = JSON.stringify(exportData, null, 2);
                
                // Create blob and download link
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Format date for filename
                const date = new Date();
                const dateStr = date.toISOString().split('T')[0];
                
                // Create download link
                const a = document.createElement('a');
                a.href = url;
                a.download = `inventory_export_${dateStr}.json`;
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
                
                console.log('Data exported successfully');
            } catch (error) {
                console.error('Error exporting data:', error);
                alert('Error exporting data: ' + error.message);
            }
        }
        
        function importData() {
            // Trigger file input click
            const importFile = document.getElementById('settingsImportFile');
            if (importFile) {
                importFile.click();
            } else {
                console.error('Import file input not found');
                alert('Error: Import functionality not available');
            }
        }
        
        async function handleImportFile(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;
                
                // Confirm before importing
                if (!confirm('Importing data will replace all current data. Continue?')) {
                    event.target.value = null;
                    return;
                }
                
                // Start import immediately after confirmation
                const reader = new FileReader();
                
                reader.onload = async (e) => {
                    try {
                        // Parse JSON data
                        const importData = JSON.parse(e.target.result);
                        
                        // Validate data structure
                        if (!importData.products || !importData.locations || !importData.inventory) {
                            throw new Error('Invalid import file format');
                        }
                        
                        // Import each store
                        if (importData.products && Array.isArray(importData.products)) {
                            await saveToIndexedDB('products', importData.products);
                            products = importData.products;
                        }
                        
                        if (importData.locations && Array.isArray(importData.locations)) {
                            await saveToIndexedDB('locations', importData.locations);
                            locations = importData.locations;
                        }
                        
                        if (importData.inventory && Array.isArray(importData.inventory)) {
                            await saveToIndexedDB('inventory', importData.inventory);
                            inventoryItems = importData.inventory;
                        }
                        
                        if (importData.transactions && Array.isArray(importData.transactions)) {
                            await saveToIndexedDB('transactions', importData.transactions);
                            transactions = importData.transactions;
                        }
                        
                        if (importData.users && Array.isArray(importData.users)) {
                            await saveToIndexedDB('users', importData.users);
                            users = importData.users;
                        }
                        
                        if (importData.floorPlans && Array.isArray(importData.floorPlans)) {
                            // Clear existing floor plans
                            const tx = db.transaction('floorPlans', 'readwrite');
                            await tx.objectStore('floorPlans').clear();
                            await tx.done;
                            
                            // Import floor plans
                            for (const floorPlan of importData.floorPlans) {
                                await db.put('floorPlans', floorPlan);
                            }
                        }
                        
                        // Set current location to first available
                        if (locations.length > 0) {
                            currentLocation = locations[0].id;
                            locationFilter = locations[0].id;
                        }
                        
                        // Update UI
                        await loadUsers();
                        updateLocationSelect();
                        updateTable();
                        updateHistory();
                        
                        console.log('Data imported successfully');
                        alert('Data imported successfully!');
                        
                        // Close settings modal if it's open
                        closeSettings();
                    } catch (error) {
                        console.error('Error parsing import file:', error);
                        alert('Error importing data: ' + error.message);
                    }
                };
                
                reader.onerror = () => {
                    console.error('Error reading file');
                    alert('Error reading file');
                };
                
                reader.readAsText(file);
                
                // Reset file input
                event.target.value = null;
            } catch (error) {
                console.error('Error handling import file:', error);
                alert('Error handling import file: ' + error.message);
            }
        }

        // Rebuild from History
        function confirmRebuildFromHistory() {
            const proceed = confirm(t('Are you sure you want to rebuild all data from the transaction history? This will overwrite current products, inventory and locations.'));
            if (!proceed) return;
            rebuildFromHistory();
        }

        async function rebuildFromHistory() {
            try {
                // Load transactions (authoritative log)
                const storedTransactions = await loadFromIndexedDB('transactions');
                const history = Array.isArray(storedTransactions) ? storedTransactions : (Array.isArray(transactions) ? transactions : []);

                // Reset state
                products = [];
                locations = [];
                inventoryItems = [];

                const productById = new Map();
                const locationById = new Map();

                function ensureDefaultLocation() {
                    if (locations.length === 0) {
                        const def = { id: '1', name: 'Location 1' };
                        locations.push(def);
                        locationById.set(def.id, def);
                    }
                }

                const sorted = [...history].sort((a, b) => new Date(a.timestamp || 0) - new Date(b.timestamp || 0));

                for (const tx of sorted) {
                    switch (tx.type) {
                        case 'create_product': {
                            if (!tx.productId) break;
                            if (!productById.has(tx.productId)) {
                                const prod = {
                                    id: tx.productId,
                                    name: tx.productName || `Product ${tx.productId}`,
                                    price: typeof tx.price === 'number' ? tx.price : 0,
                                    comments: '',
                                    barcode: tx.barcode || ''
                                };
                                products.push(prod);
                                productById.set(prod.id, prod);
                            }
                            break;
                        }
                        case 'edit_product': {
                            const prod = tx.productId ? (productById.get(tx.productId) || null) : null;
                            if (!prod) break;
                            if (tx.field === 'name' && typeof tx.newValue === 'string') prod.name = tx.newValue;
                            if (tx.field === 'price' && typeof tx.newValue === 'number') prod.price = tx.newValue;
                            break;
                        }
                        case 'update_comments': {
                            const prod = tx.productId ? (productById.get(tx.productId) || null) : null;
                            if (!prod) break;
                            if (typeof tx.newValue === 'string') prod.comments = tx.newValue;
                            break;
                        }
                        case 'assign_barcode': {
                            const prod = tx.productId ? (productById.get(tx.productId) || null) : null;
                            if (!prod) break;
                            if (typeof tx.newValue === 'string') prod.barcode = tx.newValue;
                            break;
                        }
                        case 'remove_barcode': {
                            const prod = tx.productId ? (productById.get(tx.productId) || null) : null;
                            if (!prod) break;
                            prod.barcode = '';
                            break;
                        }
                        case 'delete_product': {
                            if (!tx.productId) break;
                            products = products.filter(p => p.id !== tx.productId);
                            productById.delete(tx.productId);
                            inventoryItems = inventoryItems.filter(item => item.productId !== tx.productId);
                            break;
                        }
                        case 'add_location': {
                            if (tx.location && tx.location.id) {
                                const loc = { id: String(tx.location.id), name: tx.location.name || `Location ${locations.length + 1}` };
                                if (!locationById.has(loc.id)) {
                                    locations.push(loc);
                                    locationById.set(loc.id, loc);
                                }
                            }
                            break;
                        }
                        case 'rename_location': {
                            const locId = tx.locationId ? String(tx.locationId) : null;
                            if (locId && locationById.has(locId)) {
                                locationById.get(locId).name = tx.newName || locationById.get(locId).name;
                            }
                            break;
                        }
                        case 'delete_location': {
                            if (tx.location && tx.location.id) {
                                const id = String(tx.location.id);
                                locations = locations.filter(l => l.id !== id);
                                locationById.delete(id);
                                inventoryItems = inventoryItems.filter(item => item.locationId !== id);
                            }
                            break;
                        }
                        case 'add_inventory': {
                            ensureDefaultLocation();
                            const productId = tx.productId;
                            const locationId = tx.locationId ? String(tx.locationId) : (locations[0]?.id || '1');
                            if (!productId) break;
                            if (!productById.has(productId)) {
                                const prod = {
                                    id: productId,
                                    name: tx.productName || `Product ${productId}`,
                                    price: 0,
                                    comments: '',
                                    barcode: ''
                                };
                                products.push(prod);
                                productById.set(prod.id, prod);
                            }
                            if (!locationById.has(locationId)) {
                                const loc = { id: locationId, name: `Location ${locations.length + 1}` };
                                locations.push(loc);
                                locationById.set(loc.id, loc);
                            }
                            const quantityToAdd = Number(tx.quantity) || 0;
                            if (quantityToAdd <= 0) break;
                            let inv = inventoryItems.find(i => i.productId === productId && i.locationId === locationId);
                            if (inv) {
                                inv.quantity += quantityToAdd;
                            } else {
                                inv = { id: Date.now().toString() + Math.random().toString(36).slice(2,7), productId, locationId, quantity: quantityToAdd };
                                inventoryItems.push(inv);
                            }
                            break;
                        }
                        case 'update_quantity': {
                            ensureDefaultLocation();
                            const productId = tx.productId;
                            const locationId = tx.locationId ? String(tx.locationId) : (locations[0]?.id || '1');
                            if (!productId) break;
                            if (!productById.has(productId)) {
                                const prod = {
                                    id: productId,
                                    name: tx.productName || `Product ${productId}`,
                                    price: 0,
                                    comments: '',
                                    barcode: ''
                                };
                                products.push(prod);
                                productById.set(prod.id, prod);
                            }
                            if (!locationById.has(locationId)) {
                                const loc = { id: locationId, name: `Location ${locations.length + 1}` };
                                locations.push(loc);
                                locationById.set(loc.id, loc);
                            }
                            const newQuantity = typeof tx.newQuantity === 'number' ? tx.newQuantity : null;
                            if (newQuantity === null) break;
                            let inv = inventoryItems.find(i => i.productId === productId && i.locationId === locationId);
                            if (inv) {
                                inv.quantity = newQuantity;
                                if (inv.quantity <= 0) {
                                    inventoryItems = inventoryItems.filter(i => !(i.productId === productId && i.locationId === locationId));
                                }
                            } else if (newQuantity > 0) {
                                inv = { id: Date.now().toString() + Math.random().toString(36).slice(2,7), productId, locationId, quantity: newQuantity };
                                inventoryItems.push(inv);
                            }
                            break;
                        }
                        case 'delete_inventory': {
                            const productId = tx.productId;
                            const locationId = tx.locationId ? String(tx.locationId) : null;
                            if (!productId) break;
                            if (locationId) {
                                inventoryItems = inventoryItems.filter(i => !(i.productId === productId && i.locationId === locationId));
                            } else {
                                inventoryItems = inventoryItems.filter(i => i.productId !== productId);
                            }
                            break;
                        }
                        default:
                            break;
                    }
                }

                await saveToIndexedDB('products', products);
                await saveToIndexedDB('locations', locations);
                await saveToIndexedDB('inventory', inventoryItems);

                // Reset current location/filter to a valid one
                if (locations.length > 0) {
                    currentLocation = locations[0].id;
                    locationFilter = locations[0].id;
                } else {
                    currentLocation = '';
                    locationFilter = null;
                }

                await loadUsers();
                updateLocationSelect();
                updateTable();
                updateHistory();

                alert(t('Rebuild complete'));
            } catch (e) {
                console.error('Rebuild error:', e);
                alert(t('Error rebuilding from history') + ': ' + (e && e.message ? e.message : e));
            }
        }

        // Add ESC key support for settings modal
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                const settingsModal = document.getElementById('settingsModal');
                if (settingsModal.style.display === 'block') {
                    closeSettings();
                } else {
                    openSettings();
                }
            }
        });

        // Settings Functions
        function openSettings() {
            const modal = document.getElementById('settingsModal');
            modal.style.display = 'block';
            
            // Update theme toggle state
            document.getElementById('settingsThemeCheckbox').checked = currentTheme === 'dark';
            
            // Load users and locations lists
            updateUsersList();
            updateLocationsList();
            
            // Add click outside listener to close settings
            window.addEventListener('click', closeSettingsOnClickOutside);
        }
        
        function closeSettings() {
            const modal = document.getElementById('settingsModal');
            modal.style.display = 'none';
            
            // Remove the click outside listener
            window.removeEventListener('click', closeSettingsOnClickOutside);
        }
        
        // Function to handle clicking outside the settings modal
        function closeSettingsOnClickOutside(event) {
            const modal = document.getElementById('settingsModal');
            const content = document.querySelector('.settings-content');
            
            // If the click is on the modal background (not on the content)
            if (event.target === modal) {
                closeSettings();
            }
        }
        
        function switchSettingsTab(tabName) {
            // Hide all panels
            document.querySelectorAll('.settings-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Deactivate all tabs
            document.querySelectorAll('.settings-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected panel
            document.getElementById(tabName + 'Settings').classList.add('active');
            
            // Activate selected tab
            document.querySelector(`.settings-tab[onclick="switchSettingsTab('${tabName}')"]`).classList.add('active');
        }
        
        function updateUsersList() {
            const usersList = document.getElementById('usersList');
            usersList.innerHTML = '';
            
            users.forEach(user => {
                const listItem = document.createElement('div');
                listItem.className = 'settings-list-item';
                const isCurrentUser = user.name === currentUser;
                listItem.innerHTML = `
                    <span>${user.name}${isCurrentUser ? ' <span data-i18n="(Current)">(Current)</span>' : ''}</span>
                    <div class="item-actions">
                        <button onclick="renameUserFromSettings('${user.id}')" data-i18n="Rename">Rename</button>
                        ${!isCurrentUser ? `<button onclick="deleteUserFromSettings('${user.id}')" class="danger-btn" data-i18n="Delete">Delete</button>` : ''}
                    </div>
                `;
                usersList.appendChild(listItem);
            });
        }
        
        function updateLocationsList() {
            const locationsList = document.getElementById('locationsList');
            locationsList.innerHTML = '';
            
            locations.forEach(location => {
                const listItem = document.createElement('div');
                listItem.className = 'settings-list-item';
                const isCurrentLocation = location.id === currentLocation;
                listItem.innerHTML = `
                    <span>${location.name}${isCurrentLocation ? ' <span data-i18n="(Current)">(Current)</span>' : ''}</span>
                    <div class="item-actions">
                        <button onclick="renameLocationFromSettings('${location.id}')" data-i18n="Rename">Rename</button>
                        ${!isCurrentLocation ? `<button onclick="deleteLocationFromSettings('${location.id}')" class="danger-btn" data-i18n="Delete">Delete</button>` : ''}
                    </div>
                `;
                locationsList.appendChild(listItem);
            });
        }
        
        async function addUserFromSettings() {
            const nameInput = document.getElementById('newUserName');
            const newName = nameInput.value.trim();
            
            if (!newName) {
                alert('Please enter a user name');
                return;
            }
            
            // Check if name already exists
            if (users.some(user => user.name === newName)) {
                alert('A user with this name already exists');
                return;
            }
            
            // Create new user object
            const newUser = {
                id: 'user-' + Date.now(),
                name: newName
            };
            
            // Add to users array
            users.push(newUser);
            
            // Save to IndexedDB
            await saveToIndexedDB('users', users);
            
            // Update UI
            updateUsersList();
            nameInput.value = '';
            
            // Ensure location filter is maintained
            if (!locationFilter && locations.length > 0) {
                locationFilter = currentLocation || locations[0].id;
            }
            
            // Update user dropdown
            await loadUsers();
        }
        
        async function renameUserFromSettings(userId) {
            const user = users.find(u => u.id === userId);
            if (!user) return;
            
            const newName = prompt("Enter new name for " + user.name + ":", user.name);
            
            if (newName && newName.trim() !== "") {
                // Check if name already exists
                if (users.some(u => u.id !== userId && u.name === newName)) {
                    alert('A user with this name already exists');
                    return;
                }
                
                // Update in users array
                const oldName = user.name;
                user.name = newName;
                
                // Update current user if needed
                if (user.id === currentUserId) {
                    currentUser = newName;
                }
                
                // Update in history
                updateUserInHistory(oldName, newName);
                
                // Save to IndexedDB
                await saveToIndexedDB('users', users);
                
                // Update UI
                updateUsersList();
                
                // Ensure location filter is maintained
                if (!locationFilter && locations.length > 0) {
                    locationFilter = currentLocation || locations[0].id;
                }
                
                // Update user dropdown
                await loadUsers();
            }
        }
        
        async function deleteUserFromSettings(userId) {
            const user = users.find(u => u.id === userId);
            if (!user) return;
            
            // Prevent deleting if only one user remains
            if (users.length <= 1) {
                alert("Cannot delete the last user.");
                return;
            }
            
            if (confirm("Are you sure you want to delete user: " + user.name + "?")) {
                // Remove from users array
                users = users.filter(u => u.id !== userId);
                
                // Update current user if needed
                if (userId === currentUserId) {
                    currentUser = users[0].name;
                    currentUserId = users[0].id;
                }
                
                // Ensure location filter is maintained
                if (!locationFilter && locations.length > 0) {
                    locationFilter = currentLocation || locations[0].id;
                }
                
                // Save to IndexedDB
                await saveToIndexedDB('users', users);
                
                // Update UI
                updateUsersList();
                
                // Ensure location filter is maintained
                if (!locationFilter && locations.length > 0) {
                    locationFilter = currentLocation || locations[0].id;
                }
                
                // Update user dropdown
                await loadUsers();
            }
        }
        
        async function addLocationFromSettings() {
            const nameInput = document.getElementById('newLocationName');
            const newName = nameInput.value.trim();
            
            if (!newName) {
                alert('Please enter a location name');
                return;
            }
            
            // Check if name already exists
            if (locations.some(loc => loc.name === newName)) {
                alert('A location with this name already exists');
                return;
            }
            
            // Create new location
            const newLocationId = String(Date.now());
            const newLocation = {
                id: newLocationId,
                name: newName
            };
            
            // Add to locations array
            locations.push(newLocation);
            
            // Set as current location and filter if this is the first location
            if (locations.length === 1) {
                currentLocation = newLocationId;
                locationFilter = newLocationId;
            }
            
            // Save to IndexedDB
            await saveToIndexedDB('locations', locations);
            
            // Update UI
            updateLocationsList();
            nameInput.value = '';
            
            // Update location dropdown
            updateLocationSelect();
            renderLocationFilterButtons();
            updateHistory();
        }
        
        async function renameLocationFromSettings(locationId) {
            const location = locations.find(loc => loc.id === locationId);
            if (!location) return;
            
            const newName = prompt("Enter new name for " + location.name + ":", location.name);
            
            if (newName && newName.trim() !== "") {
                // Check if name already exists
                if (locations.some(loc => loc.id !== locationId && loc.name === newName)) {
                    alert('A location with this name already exists');
                    return;
                }
                
                const oldName = location.name;
                location.name = newName;
                
                await addToHistory({
                    type: 'rename_location',
                    locationId: locationId,
                    oldName: oldName,
                    newName: newName,
                    timestamp: new Date().toISOString()
                });
                
                // Save to IndexedDB
                await saveToIndexedDB('locations', locations);
                
                // Update UI
                updateLocationsList();
                
                // Update location dropdown
                updateLocationSelect();
                renderLocationFilterButtons();
                updateHistory();
            }
        }
        
        async function deleteLocationFromSettings(locationId) {
            const location = locations.find(loc => loc.id === locationId);
            if (!location) return;
            
            // Prevent deleting if only one location remains
            if (locations.length <= 1) {
                alert("Cannot delete the last location.");
                return;
            }
            
            if (confirm("Are you sure you want to delete location: " + location.name + "? All inventory items in this location will be deleted.")) {
                // Remove inventory items for this location
                inventoryItems = inventoryItems.filter(item => item.locationId !== locationId);
                
                // Remove the location
                locations = locations.filter(loc => loc.id !== locationId);
                
                // Update current location if needed
                if (locationId === currentLocation) {
                    currentLocation = locations[0].id;
                    locationFilter = locations[0].id;
                }
                
                await addToHistory({
                    type: 'delete_location',
                    location: location,
                    timestamp: new Date().toISOString()
                });
                
                // Save to IndexedDB
                await saveToIndexedDB('locations', locations);
                await saveToIndexedDB('inventory', inventoryItems);
                
                // Update UI
                updateLocationsList();
                
                // Update location dropdown
                renderLocationFilterButtons();
                updateTable();
                updateHistory();
            }
        }
        
        async function confirmClearData() {
            if (confirm("Are you sure you want to clear all data? This action cannot be undone.")) {
                if (confirm("FINAL WARNING: All your data will be permanently deleted. Continue?")) {
                    try {
                        // Clear all object stores
                        await db.clear('products');
                        await db.clear('locations');
                        await db.clear('inventory');
                        await db.clear('transactions');
                        await db.clear('floorPlans');
                        
                        // Reset arrays
                        products = [];
                        locations = [{ id: '1', name: 'Location 1' }];
                        inventoryItems = [];
                        transactions = [];
                        currentLocation = '1';
                        locationFilter = '1';
                        
                        // Save default location
                        await saveToIndexedDB('locations', locations);
                        
                        // Update UI
                        updateLocationSelect();
                        updateTable();
                        updateHistory();
                        
                        alert('All data has been cleared. The application has been reset to default settings.');
                    } catch (error) {
                        console.error('Error clearing data:', error);
                        alert('Error clearing data: ' + error.message);
                    }
                }
            }
        }

        // Render location filter buttons
        function renderLocationFilterButtons() {
            const container = document.getElementById('locationFilterButtons');
            if (!container) return;
            container.innerHTML = '';
            if (!locations || locations.length === 0) return;
            
            // Add "All" button first
            const allBtn = document.createElement('button');
            allBtn.textContent = 'All';
            allBtn.className = 'location-filter-btn' + (locationFilter === null ? ' selected' : '');
            allBtn.onclick = () => {
                locationFilter = null;
                currentLocation = locations[0].id;
                renderLocationFilterButtons();
                updateTable();
                updateHistory();
            };
            container.appendChild(allBtn);
            
            // Add individual location buttons with quantities
            locations.forEach(loc => {
                const btn = document.createElement('button');
                const searchTerm = document.getElementById('searchInput').value.toLowerCase();
                
                // Calculate total quantity for this location based on current search
                let locationTotal = 0;
                if (searchTerm) {
                    // Filter products by search term and sum quantities for this location
                    products.forEach(product => {
                        const matchesName = product.name.toLowerCase().includes(searchTerm);
                        const matchesBarcode = product.barcode && product.barcode.toLowerCase().includes(searchTerm);
                        if (matchesName || matchesBarcode) {
                            const inventoryItem = inventoryItems.find(item => 
                                item.productId === product.id && item.locationId === loc.id
                            );
                            if (inventoryItem) {
                                locationTotal += inventoryItem.quantity;
                            }
                        }
                    });
                } else {
                    // No search term, sum all quantities for this location
                    inventoryItems.forEach(item => {
                        if (item.locationId === loc.id) {
                            locationTotal += item.quantity;
                        }
                    });
                }
                
                btn.textContent = `${loc.name} (${locationTotal})`;
                btn.className = 'location-filter-btn' + (locationFilter === loc.id ? ' selected' : '');
                btn.onclick = () => {
                    locationFilter = loc.id;
                    currentLocation = loc.id;
                    renderLocationFilterButtons();
                    updateTable();
                    updateHistory();
                };
                container.appendChild(btn);
            });
        }

        // After the add-item-form input fields are defined, add this event listener:
        document.getElementById('itemName').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                addItem();
            }
        });

        // Add this function in the script section:
        function searchByName(name) {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.value = name;
                updateTable();
                updateHistory && updateHistory();
            }
        }

        function renderPaginationControls(containerId, currentPage, totalPages, pageSize, onPageChange, onPageSizeChange) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            // Page size selector
            const pageSizeSelect = document.createElement('select');
            [5, 10, 20, 50, 100].forEach(size => {
                const option = document.createElement('option');
                option.value = size;
                option.textContent = `${size} ${t('per_page')}`;
                if (size === pageSize) option.selected = true;
                pageSizeSelect.appendChild(option);
            });
            pageSizeSelect.onchange = (e) => onPageSizeChange(Number(e.target.value));
            container.appendChild(pageSizeSelect);

            // Prev button
            const prevBtn = document.createElement('button');
            prevBtn.textContent = t('pagination_prev');
            prevBtn.disabled = currentPage === 1;
            prevBtn.onclick = () => onPageChange(currentPage - 1);
            container.appendChild(prevBtn);

            // Page info
            const pageInfo = document.createElement('span');
            pageInfo.textContent = ` ${t('pagination_page_of').replace('{current}', currentPage).replace('{total}', totalPages)} `;
            container.appendChild(pageInfo);

            // Next button
            const nextBtn = document.createElement('button');
            nextBtn.textContent = t('pagination_next');
            nextBtn.disabled = currentPage === totalPages || totalPages === 0;
            nextBtn.onclick = () => onPageChange(currentPage + 1);
            container.appendChild(nextBtn);
        }

    </script>
</body>
</html> 