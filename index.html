<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inventory System</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>Inventory System</h1>
        
        <div class="top-actions">
            <div class="user-select">
                <span>Current User: </span>
                <select id="userSelect" onchange="changeUser(this.value)">
                </select>
            </div>
            <div class="location-select">
                <span>Current Location: </span>
                <select id="locationSelect" onchange="changeLocation(this.value)">
                </select>
                <button onclick="openFloorPlan()" class="floor-plan-button">Floor Plan</button>
            </div>
            <div class="data-actions">
                <button onclick="openBarcodeScanner()">Scan Barcode</button>
                <button onclick="openSettings()">‚öôÔ∏è Settings</button>
            </div>
        </div>

        <div class="search-container">
            <input type="text" id="searchInput" placeholder="Search items...">
        </div>
        <div id="locationFilterButtons" class="location-filter-buttons"></div>

        <div id="pendingInvoices" class="pending-invoices">
            <h2>Pending Invoices</h2>
            <div id="pendingInvoicesList"></div>
        </div>

        <div class="add-item-form">
            <input type="text" id="itemName" placeholder="Item Name">
            <input type="number" id="itemQuantity" placeholder="Quantity">
            <input type="number" id="itemPrice" placeholder="Price">
            <button onclick="addItem()">Add Item</button>
        </div>

        <table id="inventoryTable">
            <thead>
                <tr>
                    <th id="thName" onclick="setSort('name')">Name <span id="sortIconName"></span></th>
                    <th id="thQuantity" onclick="setSort('quantity')">Quantity <span id="sortIconQuantity"></span></th>
                    <th id="thPrice" onclick="setSort('price')">Price <span id="sortIconPrice"></span></th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="inventoryBody"></tbody>
        </table>

        <div class="history-section">
            <h2>Change History</h2>
            <div id="historyList"></div>
        </div>
    </div>

    <!-- Floor Plan Modal -->
    <div id="floorPlanModal" class="floor-plan-modal">
        <div class="floor-plan-content">
            <div class="floor-plan-header">
            <h2>Floor Plan - <span id="floorPlanLocationName"></span></h2>
                <div class="floor-plan-header-actions">
                    <button class="save-btn" onclick="saveFloorPlan()">Save Floor Plan</button>
                    <span class="floor-plan-close" onclick="closeFloorPlan()">&times;</span>
                </div>
            </div>
            
            <div class="floor-plan-editor">
                <div class="floor-plan-tools">
                    <button class="shape-button active" data-tool="select" onclick="selectTool('select')">Select</button>
                    <button class="shape-button" data-tool="rectangle" onclick="selectTool('rectangle')">Rectangle</button>
                    <button class="shape-button" data-tool="circle" onclick="selectTool('circle')">Circle</button>
                    <button class="shape-button" data-tool="text" onclick="selectTool('text')">Text</button>
                    <button class="shape-button" data-tool="delete" onclick="selectTool('delete')">Delete</button>
                    <input type="color" class="color-picker" id="shapeColor" value="#CCCCCC">
                    <div class="zoom-controls">
                        <button onclick="zoomFloorPlan(-0.1)" class="zoom-button">-</button>
                        <span id="zoomLevel">100%</span>
                        <button onclick="zoomFloorPlan(0.1)" class="zoom-button">+</button>
                        <button onclick="resetZoom()" class="zoom-button">Reset</button>
                    </div>
                    <div style="flex-grow: 1;"></div>
                    <button onclick="clearFloorPlan()">Clear All</button>
                </div>
                
                <div class="floor-plan-canvas-container">
                    <div id="floorPlanCanvas" style="width: 1000px; height: 600px;"></div>
                    <div id="placedProducts"></div>
                </div>
                
                <div class="product-placement-panel">
                    <h3>Place Products on Floor Plan</h3>
                    <p>Drag products onto the floor plan to show their locations</p>
                    <div class="product-placement-list" id="productList"></div>
                </div>
                
                <div class="floor-plan-actions">
                    <button onclick="viewFloorPlan()">View Mode</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add this after the floor plan modal -->
    <div id="scannerModal" class="scanner-modal">
        <div class="scanner-content">
            <span class="scanner-close" onclick="closeBarcodeScanner()">&times;</span>
            <h2>Scan Barcode</h2>
            
            <div id="scanner-container">
                <video id="video" autoplay playsinline></video>
                <canvas id="scanner-canvas"></canvas>
            </div>
            
            <div id="scannerResult" class="scanner-result"></div>
            <div id="productResult" class="product-result"></div>
            
            <div class="scanner-status" id="scanner-status">Ready to scan...</div>
            
            <div class="scanner-buttons">
                <button onclick="switchCamera()" class="switch-camera">Switch Camera</button>
                <button onclick="closeBarcodeScanner()">Close</button>
            </div>
        </div>
    </div>

    <!-- Add the barcode assignment modal -->
    <div id="barcodeModal" class="barcode-modal">
        <div class="barcode-content">
            <span class="barcode-close" onclick="closeBarcodeModal()">&times;</span>
            <h2>Assign Barcode</h2>
            <p id="barcodeProductName"></p>
            
            <div class="barcode-form">
                <div class="barcode-input-group">
                <input type="text" id="barcodeInput" placeholder="Enter barcode">
                    <button class="scan-btn" onclick="scanBarcodeForProduct()"><i class="fas fa-camera"></i> Scan</button>
                </div>
                <button class="save-btn" onclick="saveBarcode()">Save Barcode</button>
            </div>
        </div>
    </div>

    <!-- Add settings modal -->
    <div id="settingsModal" class="settings-modal">
        <div class="settings-content">
            <span class="settings-close" onclick="closeSettings()">&times;</span>
            <h2>Settings</h2>
            
            <div class="settings-tabs">
                <button class="settings-tab active" onclick="switchSettingsTab('theme')">Theme</button>
                <button class="settings-tab" onclick="switchSettingsTab('data')">Data</button>
                <button class="settings-tab" onclick="switchSettingsTab('users')">Users</button>
                <button class="settings-tab" onclick="switchSettingsTab('locations')">Locations</button>
            </div>
            
            <div id="themeSettings" class="settings-panel active">
                <h3>Theme Settings</h3>
                <div class="settings-item">
                    <label>Dark Mode</label>
                    <div class="theme-toggle-container">
                        <label class="theme-toggle-label">üåô</label>
                        <label class="theme-toggle">
                            <input type="checkbox" id="settingsThemeCheckbox" onchange="toggleThemeFromSettings()">
                            <span class="theme-toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div id="dataSettings" class="settings-panel">
                <h3>Data Management</h3>
                <div class="settings-item">
                    <label>Export Data</label>
                    <button onclick="exportData()">Export to JSON</button>
                </div>
                <div class="settings-item">
                    <label>Import Data</label>
                    <button onclick="importData()">Import from JSON</button>
                    <input type="file" id="settingsImportFile" accept=".json" style="display: none;" onchange="handleImportFile(event)">
                </div>
                <div class="settings-item">
                    <label>Clear All Data</label>
                    <button onclick="confirmClearData()" class="danger-btn">Clear Database</button>
                </div>
            </div>
            
            <div id="usersSettings" class="settings-panel">
                <h3>User Management</h3>
                <div class="settings-item">
                    <label>Add New User</label>
                    <div class="settings-input-group">
                        <input type="text" id="newUserName" placeholder="User Name">
                        <button onclick="addUserFromSettings()">Add</button>
                    </div>
                </div>
                <div class="settings-item">
                    <label>Existing Users</label>
                    <div id="usersList" class="settings-list"></div>
                </div>
            </div>
            
            <div id="locationsSettings" class="settings-panel">
                <h3>Location Management</h3>
                <div class="settings-item">
                    <label>Add New Location</label>
                    <div class="settings-input-group">
                        <input type="text" id="newLocationName" placeholder="Location Name">
                        <button onclick="addLocationFromSettings()">Add</button>
                    </div>
                </div>
                <div class="settings-item">
                    <label>Existing Locations</label>
                    <div id="locationsList" class="settings-list"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/idb@8/build/umd.js"></script>
    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ericblade/quagga2/dist/quagga.min.js"></script>
    <script type="module">
        import { BrowserMultiFormatReader, NotFoundException } from 'https://cdn.jsdelivr.net/npm/@zxing/library@0.21.3/+esm';
        window.BrowserMultiFormatReader = BrowserMultiFormatReader;
        window.NotFoundException = NotFoundException;
    </script>

    <script >

        let products = [];
        let inventoryItems = [];
        let locations = [];
        let transactions = [];
        let users = [];
        let currentLocation = '';
        let currentUser = 'User 1';
        let currentUserId = '';
        let db;
        let currentTheme = localStorage.getItem('theme') || 'light';
        let locationFilter = null; // null = all, or location id

        // Set up theme on initial load
        function applyTheme() {
            if (currentTheme === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark');
                // Update both checkboxes if they exist
                const mainCheckbox = document.getElementById('themeCheckbox');
                const settingsCheckbox = document.getElementById('settingsThemeCheckbox');
                
                if (mainCheckbox) mainCheckbox.checked = true;
                if (settingsCheckbox) settingsCheckbox.checked = true;
                
                document.querySelector('.theme-toggle-label').textContent = '‚òÄÔ∏è';
            } else {
                document.documentElement.setAttribute('data-theme', 'light');
                // Update both checkboxes if they exist
                const mainCheckbox = document.getElementById('themeCheckbox');
                const settingsCheckbox = document.getElementById('settingsThemeCheckbox');
                
                if (mainCheckbox) mainCheckbox.checked = false;
                if (settingsCheckbox) settingsCheckbox.checked = false;
                
                document.querySelector('.theme-toggle-label').textContent = 'üåô';
            }
        }

        // Apply theme immediately
        applyTheme();

        // Toggle between light and dark mode
        function toggleTheme() {
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            localStorage.setItem('theme', currentTheme);
            applyTheme();
        }

        // Toggle theme from settings
        function toggleThemeFromSettings() {
            toggleTheme();
        }

        const initDB = async () => {
            try {
                db = await idb.openDB('inventoryDB', 4, {
                    upgrade(db, oldVersion, newVersion, transaction) {
                        console.log(`Upgrading database from version ${oldVersion} to ${newVersion}`);
                        
                        // Create object stores matching the schema in README
                        if (!db.objectStoreNames.contains('products')) {
                            const productStore = db.createObjectStore('products', { keyPath: 'id' });
                            productStore.createIndex('name', 'name', { unique: false });
                        }
                        
                    if (!db.objectStoreNames.contains('locations')) {
                            const locationStore = db.createObjectStore('locations', { keyPath: 'id' });
                            locationStore.createIndex('name', 'name', { unique: false });
                        }
                        
                    if (!db.objectStoreNames.contains('inventory')) {
                            const inventoryStore = db.createObjectStore('inventory', { keyPath: 'id', autoIncrement: false });
                            inventoryStore.createIndex('productId', 'productId', { unique: false });
                            inventoryStore.createIndex('locationId', 'locationId', { unique: false });
                            inventoryStore.createIndex('product_location', ['productId', 'locationId'], { unique: true });
                        }
                        
                        if (!db.objectStoreNames.contains('transactions')) {
                            db.createObjectStore('transactions', { keyPath: 'timestamp' });
                        }
                        
                        // Add floor plans store
                        if (!db.objectStoreNames.contains('floorPlans')) {
                            db.createObjectStore('floorPlans', { keyPath: 'locationId' });
                        }
                        
                        // Add users store
                        if (!db.objectStoreNames.contains('users')) {
                            console.log('Creating users object store');
                            db.createObjectStore('users', { keyPath: 'id' });
                        }
                    }
                });
                
                console.log('IndexedDB initialized with idb module');
                return db;
            } catch (error) {
                console.error('Error initializing database:', error);
                throw error;
            }
        };

        const saveToIndexedDB = async (storeName, data) => {
            try {
                
                await db.clear(storeName);
                
                for (const item of data) {
                    await db.add(storeName, item);
                }
                
                console.log(`Data saved to ${storeName} successfully`);
            } catch (error) {
                console.error(`Error saving data to ${storeName}:`, error);
                throw error;
            }
        };

        const loadFromIndexedDB = async (storeName) => {
            try {
                const data = await db.getAll(storeName);
                return data;
                } catch (error) {
                console.error(`Error loading data from ${storeName}:`, error);
                throw error;
            }
        };

        const loadData = async () => {
            try {
                products = await loadFromIndexedDB('products') || [];
                locations = await loadFromIndexedDB('locations') || [];
                inventoryItems = await loadFromIndexedDB('inventory') || [];
                transactions = await loadFromIndexedDB('transactions') || [];
                
                // Try to load users, handle errors gracefully
                try {
                    users = await loadFromIndexedDB('users') || [];
                    console.log('Loaded users:', users);
                } catch (error) {
                    console.error('Error loading users:', error);
                    users = [];
                }
                
                // Set default location if empty
                if (locations.length === 0) {
                    locations = [{ id: '1', name: 'Location 1' }];
                    await saveToIndexedDB('locations', locations);
                }
                
                // Set default users if empty
                if (users.length === 0) {
                    users = [
                        { id: 'user-1', name: 'User 1' },
                        { id: 'user-2', name: 'User 2' }
                    ];
                    try {
                        await saveToIndexedDB('users', users);
                        console.log('Created default users:', users);
                    } catch (error) {
                        console.error('Error saving default users:', error);
                        // We'll continue with in-memory users even if saving fails
                    }
                }
                
                // Set current user
                if (users.length > 0) {
                    currentUser = users[0].name;
                    currentUserId = users[0].id;
                }
                
                // Add example product if no products exist
                if (products.length === 0) {
                    // Create example product
                    const exampleProduct = {
                        id: 'example-1',
                        name: 'Example Product',
                        price: 9.99,
                        comments: 'This is an example product to help you get started.',
                        barcode: '1234567890', // Example barcode
                    };
                    products.push(exampleProduct);
                    
                    // Add to inventory at default location
                    const exampleInventory = {
                        id: 'inv-example-1',
                        productId: exampleProduct.id,
                        locationId: locations[0].id,
                        quantity: 5
                    };
                    inventoryItems.push(exampleInventory);
                    
                    // Create initial transaction
                    const initialTransaction = {
                        type: 'add_inventory',
                        productId: exampleProduct.id,
                        productName: exampleProduct.name,
                        locationId: locations[0].id,
                        quantity: 5,
                        timestamp: new Date().toISOString()
                    };
                    transactions.push(initialTransaction);
                    
                    // Save the example data
                    await saveToIndexedDB('products', products);
                    await saveToIndexedDB('inventory', inventoryItems);
                    await saveToIndexedDB('transactions', transactions);
                    
                    console.log('Added example product to database');
                }
                
                // Set current location
                currentLocation = locations[0]?.id || '1';
                
                console.log('Data loaded:', {
                    products: products.length,
                    locations: locations.length,
                    inventory: inventoryItems.length,
                    transactions: transactions.length
                });
            } catch (error) {
                console.error('Error loading data:', error);
                // Set defaults
                products = [];
                locations = [{ id: '1', name: 'Location 1' }];
                inventoryItems = [];
                transactions = [];
                currentLocation = '1';
            }
        };

        // Initialize database and load data
        const initializeData = async () => {
            try {
                await initDB();
                console.log('IndexedDB initialized');
                await loadData();
                
                // Initialize users dropdown
                await loadUsers();

                // Update UI
                updateLocationSelect();
                updateTable();
                updateHistory();
            } catch (error) {
                console.error('Error initializing database:', error);
                alert('Error loading data. Using default values.');
                
                // Fallback to empty data
                products = [];
                locations = [{ id: '1', name: 'Location 1' }];
                inventoryItems = [];
                transactions = [];
                currentLocation = '1';
                
                // Update UI with default data
                updateLocationSelect();
                updateTable();
                updateHistory();
            }
        };

            
        async function save() {
            try {
                console.log('Saving data to IndexedDB:', {
                    products: products.length,
                    locations: locations.length,
                    inventory: inventoryItems.length,
                    transactions: transactions.length
                });
                
                // Save one store at a time to better isolate errors
                try {
                    await saveToIndexedDB('products', products);
                    console.log('Products saved successfully');
            } catch (error) {
                    console.error('Error saving products:', error);
                    alert(`Error saving products data: ${error.message || 'Unknown error'}`);
                    throw error;
                }
                
                try {
                    await saveToIndexedDB('locations', locations);
                    console.log('Locations saved successfully');
                } catch (error) {
                    console.error('Error saving locations:', error);
                    alert(`Error saving locations data: ${error.message || 'Unknown error'}`);
                    throw error;
                }
                
                try {
                    await saveToIndexedDB('inventory', inventoryItems);
                    console.log('Inventory saved successfully');
                } catch (error) {
                    console.error('Error saving inventory:', error);
                    alert(`Error saving inventory data: ${error.message || 'Unknown error'}`);
                    throw error;
                }
                
                try {
                    await saveToIndexedDB('transactions', transactions);
                    console.log('Transactions saved successfully');
                } catch (error) {
                    console.error('Error saving transactions:', error);
                    alert(`Error saving transactions data: ${error.message || 'Unknown error'}`);
                    throw error;
                }
                
                console.log('All data saved successfully');
            } catch (error) {
                console.error('Error in saveToLocalStorage:', error);
                alert('Error saving data. Please check console for details.');
            }
        }

        function updateLocationSelect() {
            const select = document.getElementById('locationSelect');
            select.innerHTML = '';
            
            locations.forEach(location => {
                const option = document.createElement('option');
                option.value = location.id;
                option.textContent = location.name;
                if (location.id === currentLocation) {
                    option.selected = true;
                }
                select.appendChild(option);
            });

            // If no location is selected, select the first one
            if (!currentLocation && locations.length > 0) {
                currentLocation = locations[0].id;
                select.value = currentLocation;
            }
            renderLocationFilterButtons();
        }

        function changeLocation(selectedLocationId) {
            if (!selectedLocationId && locations.length > 0) {
                // If somehow no location is selected, select the first one
                selectedLocationId = locations[0].id;
                document.getElementById('locationSelect').value = selectedLocationId;
            }
            currentLocation = selectedLocationId;
            updateTable();
        }

        async function renameLocation() {
            const newName = document.getElementById('locationName').value.trim();
            if (!newName) {
                alert('Location name cannot be empty');
                const currentLoc = locations.find(loc => loc.id === currentLocation);
                document.getElementById('locationName').value = currentLoc ? currentLoc.name : '';
                return;
            }

            const locationIndex = locations.findIndex(loc => loc.id === currentLocation);
            if (locationIndex !== -1) {
                const oldName = locations[locationIndex].name;
                locations[locationIndex].name = newName;
            
            await addToHistory({
                type: 'rename_location',
                    locationId: currentLocation,
                oldName: oldName,
                newName: newName,
                timestamp: new Date().toISOString()
            });

                await save();
            updateLocationSelect();
            }
        }

        async function addLocation() {
            const newLocationId = String(Date.now());
            const newLocation = {
                id: newLocationId,
                name: `Location ${locations.length + 1}`
            };
            
            locations.push(newLocation);
            currentLocation = newLocationId;
            
            await addToHistory({
                type: 'add_location',
                location: newLocation,
                timestamp: new Date().toISOString()
            });
            
            await save();
            updateLocationSelect();
            updateTable();
        }

        async function deleteLocation() {
            if (locations.length <= 1) {
                alert('Cannot delete the last location');
                return;
            }
            
            if (confirm('Are you sure you want to delete this location? All inventory items in this location will be deleted.')) {
                // Remove inventory items for this location
                inventoryItems = inventoryItems.filter(item => item.locationId !== currentLocation);
                
                // Remove the location
                const locationIndex = locations.findIndex(loc => loc.id === currentLocation);
                const deletedLocation = locations[locationIndex];
                locations.splice(locationIndex, 1);
                
                // Update current location to first available
                currentLocation = locations[0].id;
                
                await addToHistory({
                    type: 'delete_location',
                    location: deletedLocation,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateLocationSelect();
                updateTable();
            }
        }

        async function addItem() {
            const name = document.getElementById('itemName').value.trim();
            const quantity = parseInt(document.getElementById('itemQuantity').value);
            const price = parseFloat(document.getElementById('itemPrice').value);

            if (!name || isNaN(quantity) || isNaN(price) || quantity < 0 || price < 0) {
                alert('Please fill all fields with valid values');
                return;
            }

            // Create product if it doesn't exist
            let product = products.find(p => p.name.toLowerCase() === name.toLowerCase());
            
            if (!product) {
                product = { 
                    id: Date.now().toString(),
                name, 
                price,
                    comments: '',
                    barcode: '', 
                };
                products.push(product);
            }
            
            // Check if inventory entry exists
            let inventoryEntry = inventoryItems.find(item => 
                item.productId === product.id && item.locationId === currentLocation
            );
            
            if (inventoryEntry) {
                // Update existing inventory
                const oldQuantity = inventoryEntry.quantity;
                inventoryEntry.quantity += quantity;
                
            await addToHistory({
                    type: 'update_quantity',
                    productId: product.id,
                    productName: product.name,
                    locationId: currentLocation,
                    oldQuantity,
                    newQuantity: inventoryEntry.quantity,
                timestamp: new Date().toISOString()
            });
            } else {
                // Create new inventory entry
                inventoryEntry = {
                    id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                    productId: product.id,
                    locationId: currentLocation,
                    quantity
                };
                
                inventoryItems.push(inventoryEntry);
                
                await addToHistory({
                    type: 'add_inventory',
                    productId: product.id,
                    productName: product.name,
                    locationId: currentLocation,
                    quantity,
                    timestamp: new Date().toISOString()
                });
            }

            await save();
            updateTable();
            clearForm();
        }

        async function deleteItem(productId) {
            const product = products.find(p => p.id === productId);
            if (!product) return;
            
            if (confirm(`Are you sure you want to delete "${product.name}" from all locations?`)) {
                // Get all inventory entries for this product
                const affectedEntries = inventoryItems.filter(item => item.productId === productId);
                
                // Record each deletion in history
                for (const entry of affectedEntries) {
                    const locationName = locations.find(loc => loc.id === entry.locationId)?.name || 'Unknown';
                    
                await addToHistory({
                        type: 'delete_inventory',
                        productId,
                        productName: product.name,
                        locationId: entry.locationId,
                        locationName,
                        quantity: entry.quantity,
                    timestamp: new Date().toISOString()
                });
                }
                
                // Remove all inventory entries for this product
                inventoryItems = inventoryItems.filter(item => item.productId !== productId);
                
                // Remove the product completely
                products = products.filter(p => p.id !== productId);
                
                await addToHistory({
                    type: 'delete_product',
                    productId,
                    productName: product.name,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateTable();
            }
        }

        async function editField(productId, field, element) {
            const product = products.find(p => p.id === productId);
            if (!product) return;

            const currentValue = element.textContent;
            const input = document.createElement('input');
            input.type = field === 'price' ? 'number' : field === 'quantity' ? 'number' : 'text';
            input.step = field === 'price' ? '0.01' : '1';
            input.min = field === 'quantity' || field === 'price' ? '0' : '';
            input.value = currentValue;
            input.className = 'editable editing';
            
            element.textContent = '';
            element.appendChild(input);
            input.focus();

            async function saveEdit() {
                const newValue = input.value;
                if (newValue === currentValue) {
                    element.textContent = currentValue;
                    return;
                }
                
                if (field === 'price') {
                    const newPrice = parseFloat(newValue);
                    if (!isNaN(newPrice) && newPrice >= 0) {
                        const oldPrice = product.price;
                        product.price = newPrice;
                        
                        await addToHistory({
                            type: 'edit_product',
                            productId: product.id,
                            productName: product.name,
                            field: 'price',
                            oldValue: oldPrice,
                            newValue: newPrice,
                            timestamp: new Date().toISOString()
                        });
                        
                        await save();
                        updateTable();
                    } else {
                        element.textContent = currentValue;
                        return;
                    }
                } else if (field === 'name') {
                    const newName = newValue.trim();
                    if (newName) {
                        const oldName = product.name;
                        product.name = newName;
                        
                        await addToHistory({
                            type: 'edit_product',
                            productId: product.id,
                            productName: newName,
                            field: 'name',
                            oldValue: oldName,
                            newValue: newName,
                            timestamp: new Date().toISOString()
                        });
                        
                        await save();
                        updateTable();
                    } else {
                        element.textContent = currentValue;
                        return;
                    }
                } else if (field === 'quantity') {
                    const newQuantity = parseInt(newValue);
                    if (!isNaN(newQuantity) && newQuantity >= 0) {
                        // Find inventory entry for this product and location
                        let inventoryEntry = inventoryItems.find(item => 
                            item.productId === productId && item.locationId === currentLocation
                        );
                        
                        if (inventoryEntry) {
                            const oldQuantity = inventoryEntry.quantity;
                            inventoryEntry.quantity = newQuantity;
                            
                            await addToHistory({
                                type: 'update_quantity',
                                productId: product.id,
                                productName: product.name,
                                locationId: currentLocation,
                                oldQuantity,
                                newQuantity,
                                timestamp: new Date().toISOString()
                            });
                        } else if (newQuantity > 0) {
                            // Create new inventory entry
                            inventoryEntry = {
                                id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                                productId: product.id,
                                locationId: currentLocation,
                                quantity: newQuantity
                            };
                            
                            inventoryItems.push(inventoryEntry);
                            
                            await addToHistory({
                                type: 'add_inventory',
                                productId: product.id,
                                productName: product.name,
                                locationId: currentLocation,
                                quantity: newQuantity,
                                timestamp: new Date().toISOString()
                            });
                        }
                        
                        await save();
                        updateTable();
                    } else {
                        element.textContent = currentValue;
                        return;
                    }
                }
            }

            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                    input.blur();
                }
            });
        }

        function toggleDetails(id) {
            const details = document.getElementById(`details-${id}`);
            const button = event.target;
            if (details.classList.contains('show')) {
                details.classList.remove('show');
                button.textContent = '‚ñº';
            } else {
                details.classList.add('show');
                button.textContent = '‚ñ≤';
            }
        }

        async function updateComments(productId) {
            const product = products.find(p => p.id === productId);
            if (!product) return;

            const newComments = document.getElementById(`comments-${productId}`).value;
            
            if (product.comments !== newComments) {
                const oldComments = product.comments || '';
                product.comments = newComments;

                await addToHistory({
                    type: 'update_comments',
                    productId: product.id,
                    productName: product.name,
                    oldValue: oldComments,
                    newValue: newComments,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateTable();
            }
        }

        async function changeQuantity(productId, change) {
            const product = products.find(item => item.id === productId);
            if (!product) return;
            
            // Find inventory entry for this product and location
            let inventoryEntry = inventoryItems.find(item => 
                item.productId === productId && item.locationId === currentLocation
            );
            
            if (inventoryEntry) {
                // Update existing entry
                const oldQuantity = inventoryEntry.quantity;
                const newQuantity = oldQuantity + change;
                
                if (newQuantity >= 0) {
                    inventoryEntry.quantity = newQuantity;
                    
                    await addToHistory({
                        type: 'update_quantity',
                        productId: product.id,
                        productName: product.name,
                        locationId: currentLocation,
                        oldQuantity,
                        newQuantity,
                        timestamp: new Date().toISOString()
                    });
                    
                    await save();
                    updateTable();
                }
            } else if (change > 0) {
                // Create new inventory entry
                inventoryEntry = {
                    id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                    productId: product.id,
                    locationId: currentLocation,
                    quantity: change
                };
                
                inventoryItems.push(inventoryEntry);
                
                await addToHistory({
                    type: 'add_inventory',
                    productId: product.id,
                    productName: product.name,
                    locationId: currentLocation,
                    quantity: change,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateTable();
            }
        }

        // Allow direct editing of location quantity by clicking on the value
        async function editLocationQuantity(productId, locationId, element) {
            const product = products.find(p => p.id === productId);
            if (!product) return;

            const currentValue = element.textContent;
            const input = document.createElement('input');
            input.type = 'number';
            input.step = '1';
            input.min = '0';
            input.value = currentValue;
            input.className = 'quantity-value editing';
            input.style.width = '40px';
            
            element.textContent = '';
            element.appendChild(input);
            input.focus();

            async function saveEdit() {
                const newValue = parseInt(input.value);
                const oldValue = parseInt(currentValue);
                
                if (isNaN(newValue) || newValue === oldValue) {
                    element.textContent = currentValue;
                    return;
                }
                
                if (newValue >= 0) {
                    // Find inventory entry for this product and location
                    let inventoryEntry = inventoryItems.find(item => 
                        item.productId === productId && item.locationId === locationId
                    );
                    
                    if (inventoryEntry) {
                        inventoryEntry.quantity = newValue;
                        
                        await addToHistory({
                            type: 'update_quantity',
                            productId: product.id,
                            productName: product.name,
                            locationId: locationId,
                            oldQuantity: oldValue,
                            newQuantity: newValue,
                            timestamp: new Date().toISOString()
                        });
                    } else if (newValue > 0) {
                        // Create new inventory entry
                        inventoryEntry = {
                            id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                            productId: product.id,
                            locationId: locationId,
                            quantity: newValue
                        };
                        
                        inventoryItems.push(inventoryEntry);
                        
                        await addToHistory({
                            type: 'add_inventory',
                            productId: product.id,
                            productName: product.name,
                            locationId: locationId,
                            quantity: newValue,
                            timestamp: new Date().toISOString()
                        });
                    }
                    
                    await save();
                    updateTable();
                } else {
                    element.textContent = currentValue;
                }
            }

            input.addEventListener('blur', saveEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                    input.blur();
                }
            });
        }

        // Debounce function to limit how often a function can be called
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        }
        
        // Store pending changes to show immediate visual feedback
        const pendingQuantityChanges = {};
        
        // Apply visual update immediately without saving
        function applyVisualQuantityChange(productId, locationId, change) {
            const key = `${productId}-${locationId}`;
            pendingQuantityChanges[key] = (pendingQuantityChanges[key] || 0) + change;
            
            // Find the quantity display element and update it
            const quantityElement = document.querySelector(`[data-product-id="${productId}"][data-location-id="${locationId}"]`);
            if (quantityElement) {
                const currentQuantity = parseInt(quantityElement.textContent || '0');
                const newQuantity = Math.max(0, currentQuantity + change);
                quantityElement.textContent = newQuantity;
            }
            
            // Update total if needed
            const totalElement = document.querySelector(`[data-product-id="${productId}"][data-total="true"]`);
            if (totalElement) {
                const currentTotal = parseInt(totalElement.textContent.replace('Total: ', '') || '0');
                const newTotal = Math.max(0, currentTotal + change);
                totalElement.textContent = `Total: ${newTotal}`;
            }
        }

        // Debounced function to actually save changes
        const saveQuantityChange = debounce(async (productId, locationId, change) => {
            const key = `${productId}-${locationId}`;
            const totalChange = pendingQuantityChanges[key] || 0;
            
            // Reset pending changes
            pendingQuantityChanges[key] = 0;
            
            if (totalChange === 0) return;
            
            const product = products.find(item => item.id === productId);
            if (!product) return;
            
            // Find inventory entry for this product and the specified location
            let inventoryEntry = inventoryItems.find(item => 
                item.productId === productId && item.locationId === locationId
            );
            
            if (inventoryEntry) {
                // Update existing entry
                const oldQuantity = inventoryEntry.quantity;
                const newQuantity = Math.max(0, oldQuantity + totalChange);
                
                inventoryEntry.quantity = newQuantity;
                
                await addToHistory({
                    type: 'update_quantity',
                    productId: product.id,
                    productName: product.name,
                    locationId: locationId,
                    oldQuantity,
                    newQuantity,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateTable();
            } else if (totalChange > 0) {
                // Create new inventory entry
                inventoryEntry = {
                    id: Date.now().toString() + Math.random().toString(36).substr(2, 5),
                    productId: product.id,
                    locationId: locationId,
                    quantity: totalChange
                };
                
                inventoryItems.push(inventoryEntry);
                
                await addToHistory({
                    type: 'add_inventory',
                    productId: product.id,
                    productName: product.name,
                    locationId: locationId,
                    quantity: totalChange,
                    timestamp: new Date().toISOString()
                });
                
                await save();
                updateTable();
            }
        }, 500); // 500ms debounce time
        
        // Function to change quantity with debounce
        function changeSpecificLocationQuantityWithDebounce(productId, locationId, change) {
            // Apply visual change immediately
            applyVisualQuantityChange(productId, locationId, change);
            
            // Schedule the actual save after debounce
            saveQuantityChange(productId, locationId, change);
        }

        function clearForm() {
            document.getElementById('itemName').value = '';
            document.getElementById('itemQuantity').value = '';
            document.getElementById('itemPrice').value = '';
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${day}-${month}-${year} ${hours}:${minutes}`;
        }

        function updateHistory() {
            const historyList = document.getElementById('historyList');
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            historyList.innerHTML = '';
            
            if (!Array.isArray(transactions)) {
                console.warn('Transactions is not an array:', transactions);
                return;
            }
            
            // Sort transactions by timestamp (newest first)
            const sortedTransactions = [...transactions].sort((a, b) => 
                new Date(b.timestamp) - new Date(a.timestamp)
            );
            
            // Filter transactions if search term is provided
            const filteredTransactions = searchTerm ? 
                sortedTransactions.filter(transaction => 
                    (transaction.productName && transaction.productName.toLowerCase().includes(searchTerm)) || 
                    (transaction.productId && products.some(p => 
                        p.id === transaction.productId && 
                        p.name.toLowerCase().includes(searchTerm)
                    ))
                ) : 
                sortedTransactions;
            
            filteredTransactions.forEach((transaction, index) => {
                const div = document.createElement('div');
                div.className = 'history-item';
                let changeText = '';
                
                try {
                    // Get location name if locationId exists
                    const getLocationName = (locationId) => {
                        const location = locations.find(loc => loc.id === locationId);
                        return location ? location.name : 'Unknown Location';
                    };
                    
                    switch (transaction.type) {
                        case 'add_inventory':
                            changeText = `[${transaction.user}] Added ${transaction.quantity} ${transaction.productName} to ${getLocationName(transaction.locationId)}`;
                            break;
                        case 'delete_inventory':
                            const locationDisplayName = transaction.locationName || getLocationName(transaction.locationId);
                            changeText = `[${transaction.user}] Deleted ${transaction.productName} from ${locationDisplayName}`;
                            break;
                        case 'delete_product':
                            changeText = `[${transaction.user}] Removed product ${transaction.productName} completely`;
                            break;
                        case 'update_quantity':
                            changeText = `[${transaction.user}] Changed quantity of ${transaction.productName} from ${transaction.oldQuantity} to ${transaction.newQuantity} in ${getLocationName(transaction.locationId)}`;
                            break;
                        case 'edit_product':
                            changeText = `[${transaction.user}] Changed ${transaction.field} of ${transaction.productName} from ${transaction.oldValue} to ${transaction.newValue}`;
                            break;
                        case 'update_details':
                            changeText = `[${transaction.user}] Updated details for ${transaction.productName}`;
                            break;
                        case 'add_location':
                            changeText = `[${transaction.user}] Added new location: ${transaction.location.name}`;
                            break;
                        case 'delete_location':
                            changeText = `[${transaction.user}] Deleted location: ${transaction.location.name}`;
                            break;
                        case 'rename_location':
                            changeText = `[${transaction.user}] Renamed ${transaction.oldName} to ${transaction.newName}`;
                            break;
                        case 'update_comments':
                            changeText = `[${transaction.user}] Updated comments for ${transaction.productName}`;
                            break;
                        default:
                            changeText = `[${transaction.user}] Unknown transaction type: ${transaction.type}`;
                    }
                } catch (error) {
                    console.error('Error processing transaction entry:', error, transaction);
                    changeText = 'Error: Invalid transaction entry';
                }

                div.innerHTML = `
                    <span>${changeText} - ${formatDate(transaction.timestamp)}</span>
                `;
                historyList.appendChild(div);
            });
            
            // Show a message if no matching transactions
            if (searchTerm && filteredTransactions.length === 0) {
                const noResults = document.createElement('div');
                noResults.className = 'no-results';
                noResults.textContent = 'No matching history items found.';
                historyList.appendChild(noResults);
            }
        }

        async function addToHistory(change) {
            // Add user information to the change record
            change.user = currentUser;
            change.userId = currentUserId;
            transactions.push(change);
            await save();
            updateHistory();
        }

        document.getElementById('searchInput').addEventListener('input', function() {
            updateTable();
            updateHistory(); // Also update history when search input changes
        });
                // --- Sorting State ---
                let sortColumn = 'name';
        let sortDirection = 'asc'; // 'asc' or 'desc'

        function setSort(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'asc';
            }
            updateTable();
        }

        function updateSortIcons() {
            const icons = {
                name: document.getElementById('sortIconName'),
                quantity: document.getElementById('sortIconQuantity'),
                price: document.getElementById('sortIconPrice')
            };
            Object.keys(icons).forEach(col => {
                if (sortColumn === col) {
                    icons[col].textContent = sortDirection === 'asc' ? '‚ñ≤' : '‚ñº';
                } else {
                    icons[col].textContent = '';
                }
            });
        }

        // Initial load
        updateLocationSelect();
        updateTable();
        updateHistory();

        function updateTable() {
            const tbody = document.getElementById('inventoryBody');
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            tbody.innerHTML = '';
            // Get products with inventory in any location (for total quantities)
            const productInventory = {};
            // Initialize with all products
            products.forEach(product => {
                productInventory[product.id] = {
                    product,
                    quantities: {},
                    totalQuantity: 0
                };
            });
            // Add quantities from inventory
            inventoryItems.forEach(item => {
                if (productInventory[item.productId]) {
                    productInventory[item.productId].quantities[item.locationId] = item.quantity;
                    productInventory[item.productId].totalQuantity += item.quantity;
                }
            });
            // Filter by search term and locationFilter
            const filteredProducts = Object.values(productInventory).filter(entry => {
                const product = entry.product;
                const matchesName = product.name.toLowerCase().includes(searchTerm);
                const matchesBarcode = product.barcode && product.barcode.toLowerCase().includes(searchTerm);
                // Only show if product has quantity in selected location
                const showInLocation = locationFilter ? (entry.quantities[locationFilter] > 0) : true;
                return (matchesName || matchesBarcode) && showInLocation;
            });
            // --- Sort by selected column and direction ---
            filteredProducts.sort((a, b) => {
                let valA, valB;
                if (sortColumn === 'name') {
                    valA = a.product.name.toLowerCase();
                    valB = b.product.name.toLowerCase();
                } else if (sortColumn === 'quantity') {
                    valA = a.totalQuantity;
                    valB = b.totalQuantity;
                } else if (sortColumn === 'price') {
                    valA = a.product.price;
                    valB = b.product.price;
                }
                if (valA < valB) return sortDirection === 'asc' ? -1 : 1;
                if (valA > valB) return sortDirection === 'asc' ? 1 : -1;
                return 0;
            });
            // Update sort icons
            updateSortIcons();
            // Display the products
            filteredProducts.forEach(entry => {
                const product = entry.product;
                const currentLocationQuantity = entry.quantities[currentLocation] || 0;
                
                const tr = document.createElement('tr');
                tr.className = 'item-row';
                tr.dataset.productId = product.id;
                
                const locationQuantities = locations.map(loc => {
                    const quantity = entry.quantities[loc.id] || 0;
                    const isCurrent = loc.id === currentLocation;
                    return quantity > 0 ? 
                        `<span class="location-quantity ${isCurrent ? 'current' : ''}">${loc.name}: ${quantity}</span>` : 
                        '';
                }).filter(Boolean).join('');

                const detailsHtml = `
                    <div class="item-details" id="details-${product.id}">
                        <div class="item-details-grid">
                            <div class="item-details-section">
                                <label>Comments:</label>
                                <textarea id="comments-${product.id}" onblur="updateComments('${product.id}')">${product.comments || ''}</textarea>
                            </div>
                        </div>
                    </div>
                `;

                tr.innerHTML = `
                    <td>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span class="editable" onclick="editField('${product.id}', 'name', this)">${product.name}</span>
                            <button class="toggle-details-btn" onclick="toggleDetails('${product.id}')">‚ñº</button>
                        </div>
                    </td>
                    <td>
                        <div class="total-quantity">
                            <strong data-product-id="${product.id}" data-total="true">Total: ${entry.totalQuantity}</strong>
                        </div>
                        <div class="location-quantities-list">
                            ${locations.map(loc => {
                                const locQuantity = entry.quantities[loc.id] || 0;
                                const isCurrent = loc.id === currentLocation;
                                return `
                                <div class="location-quantity-item ${isCurrent ? 'current' : ''}">
                                    <span class="location-name">${loc.name}:</span>
                                    <div class="quantity-controls">
                                        <button onclick="changeSpecificLocationQuantityWithDebounce('${product.id}', '${loc.id}', -1)" class="quantity-btn">-</button>
                                        <span class="quantity-value" data-product-id="${product.id}" data-location-id="${loc.id}" onclick="editLocationQuantity('${product.id}', '${loc.id}', this)">${locQuantity}</span>
                                        <button onclick="changeSpecificLocationQuantityWithDebounce('${product.id}', '${loc.id}', 1)" class="quantity-btn">+</button>
                                    </div>
                                </div>
                                `;
                            }).join('')}
                        </div>
                    </td>
                    <td>
                        <span class="editable" onclick="editField('${product.id}', 'price', this)">${product.price.toFixed(2)}</span>
                    </td>
                    <td>
                        <button onclick="deleteItem('${product.id}')">Delete</button>
                        <button class="barcode-btn" onclick="openBarcodeModal('${product.id}')">${product.barcode ? 'Edit Barcode' : 'Add Barcode'}</button>
                    </td>
                `;
                tbody.appendChild(tr);

                // Add details row
                const detailsRow = document.createElement('tr');
                detailsRow.className = 'item-details-row';
                detailsRow.innerHTML = `
                    <td colspan="4">
                        ${detailsHtml}
                    </td>
                `;
                tbody.appendChild(detailsRow);
            });
        }

        // Handle errors with IndexedDB
        const handleDBError = (error) => {
            console.error('IndexedDB error:', error.message);
            alert(`Database error: ${error.message}. Some features may not work correctly.`);
        };

        // Add global event handler for IndexedDB errors
        window.addEventListener('error', (event) => {
            if (event.target && event.target.error && event.target.error.name && 
                event.target.error.name.includes('IDB')) {
                handleDBError(event.target.error);
            }
        });

        // Initialize the app when DOM content is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize with error handling
            initializeData().catch(error => {
                console.error('Error during initialization:', error);
                alert('Failed to initialize the application. Please refresh the page or check console for details.');
            });
            // Set initial filter
            setTimeout(() => {
                if (locations && locations.length > 0) {
                    locationFilter = locations[0].id;
                    renderLocationFilterButtons();
                    updateTable();
                }
            }, 500);
        });

        // Floor Plan functionality
        let currentTool = 'select';
        let shapes = [];
        let selectedShape = null;
        let isDrawing = false;
        let startX, startY;
        let placedProducts = [];
        let isDragging = false;
        let draggedElement = null;
        let dragOffsetX, dragOffsetY;
        let canvas, ctx;
        let isEditMode = true;

        // Konva objects
        let stage;
        let layer;
        let transformer;
        let konvaShapes = [];
        let currentZoom = 1;
        let isDraggingStage = false;
        let lastPointerPosition = null;

        function openFloorPlan() {
            const modal = document.getElementById('floorPlanModal');
            modal.style.display = 'block';
            
            // Set location name
            const locationName = locations.find(loc => loc.id === currentLocation)?.name || 'Unknown Location';
            document.getElementById('floorPlanLocationName').textContent = locationName;
            
            // Reset state
            selectedShape = null;
            isDrawing = false;
            
            // Always start in select mode
            currentTool = 'select';
            
            // Update UI to show select as active
            document.querySelectorAll('.shape-button').forEach(button => {
                if (button.dataset.tool === 'select') {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                    button.classList.remove('delete-tool');
                }
            });
            
            // Initialize Konva stage
            initKonvaStage();
            
            // Load existing floor plan data
            loadFloorPlan(currentLocation);
            
            // Load products for placement
            loadProductsForPlacement();
            
            console.log('Floor plan opened, stage initialized');
        }

        function initKonvaStage() {
            // Check if stage already exists
            if (stage) {
                stage.destroy();
            }
            
            // Create Konva stage with the correct container ID
            stage = new Konva.Stage({
                container: 'floorPlanCanvas',
                width: 1000,
                height: 600
            });
            
            // Create layer for all shapes
            layer = new Konva.Layer();
            stage.add(layer);
            
            // Create transformer for shape manipulation
            transformer = new Konva.Transformer({
                nodes: [],
                enabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right'],
                rotateEnabled: true,
                borderDash: [3, 3]
            });
            layer.add(transformer);
            
            // Add wheel event listener for zooming
            stage.on('wheel', (e) => {
                e.evt.preventDefault();
                
                const oldScale = stage.scaleX();
                const pointer = stage.getPointerPosition();
                
                const mousePointTo = {
                    x: (pointer.x - stage.x()) / oldScale,
                    y: (pointer.y - stage.y()) / oldScale,
                };
                
                // Calculate new scale
                const newScale = e.evt.deltaY < 0 ? oldScale * 1.1 : oldScale / 1.1;
                
                // Limit zoom level between 0.1 and 3
                if (newScale >= 0.1 && newScale <= 3) {
                    stage.scale({ x: newScale, y: newScale });
                    
                    const newPos = {
                        x: pointer.x - mousePointTo.x * newScale,
                        y: pointer.y - mousePointTo.y * newScale,
                    };
                    
                    stage.position(newPos);
                    stage.batchDraw();
                    
                    // Update zoom level display
                    currentZoom = Math.round(newScale * 100);
                    document.getElementById('zoomLevel').textContent = `${currentZoom}%`;
                }
            });

            // Add mouse events for stage dragging
            stage.on('mousedown', (e) => {
                // Don't start dragging if clicking on a shape or transformer
                if (e.target !== stage && e.target !== layer) {
                    return;
                }

                // Only enable dragging if:
                // 1. We're in view mode (not edit mode), or
                // 2. The user is holding the shift key (for edit mode)
                if (!isEditMode || (isEditMode && e.evt.shiftKey)) {
                    isDraggingStage = true;
                    lastPointerPosition = stage.getPointerPosition();
                    document.body.style.cursor = 'grabbing';
                }
            });

            stage.on('mousemove', (e) => {
                if (!isDraggingStage) {
                    // Update cursor based on mode and shift key
                    if (!isEditMode || (isEditMode && e.evt.shiftKey)) {
                        document.body.style.cursor = 'grab';
                    } else {
                        document.body.style.cursor = 'default';
                    }
                    return;
                }

                if (!lastPointerPosition) {
                    return;
                }

                e.evt.preventDefault();
                const pos = stage.getPointerPosition();
                const dx = pos.x - lastPointerPosition.x;
                const dy = pos.y - lastPointerPosition.y;

                // Move the stage
                stage.position({
                    x: stage.x() + dx,
                    y: stage.y() + dy
                });
                stage.batchDraw();

                lastPointerPosition = pos;
            });

            stage.on('mouseup', () => {
                isDraggingStage = false;
                lastPointerPosition = null;
                document.body.style.cursor = isEditMode ? 'default' : 'grab';
            });

            // Add keyboard event listener for shift key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Shift' && isEditMode) {
                    document.body.style.cursor = 'grab';
                }
            });

            document.addEventListener('keyup', (e) => {
                if (e.key === 'Shift' && isEditMode) {
                    document.body.style.cursor = 'default';
                }
            });
            
            // Ensure the layer is drawn
            layer.draw();
            
            // Set up event listeners
            setupKonvaEvents();
            
            console.log("Konva stage initialized with container:", stage.container());
        }
        
        function setupKonvaEvents() {
            // Clear only the click event listener, preserve stage dragging events
            stage.off('click');
            
            // Stage click handler for selection
            stage.on('click', function(e) {
                // Log the click for debugging
                console.log("Stage clicked", e.target, "current tool:", currentTool);
                
                // If clicked on empty stage
                if (e.target === stage) {
                    transformer.nodes([]);
                    selectedShape = null;
                    layer.draw();
                    return;
                }
                
                // Handle delete tool
                if (currentTool === 'delete') {
                    try {
                        const clickedShape = e.target;
                        console.log("Attempting to delete shape:", clickedShape);
                        
                        // Remove from transformer
                        transformer.nodes([]);
                        
                        // If it's a basic shape, remove from konvaShapes
                        const shapeIndex = konvaShapes.indexOf(clickedShape);
                        if (shapeIndex > -1) {
                            konvaShapes.splice(shapeIndex, 1);
                        }
                        
                        // If it's a group with a product ID, remove from placedProducts
                        if (clickedShape instanceof Konva.Group && clickedShape.attrs.productId) {
                            const productId = clickedShape.attrs.productId;
                            placedProducts = placedProducts.filter(p => p.productId !== productId);
                        }
                        
                        // Delete the shape
                        clickedShape.destroy();
                        selectedShape = null;
                        layer.draw();
                        
                        console.log("Shape deleted with delete tool, staying in delete mode");
                        
                        // No need to switch tools - stay in delete mode
                        return;
                    } catch (error) {
                        console.error("Error deleting shape with delete tool:", error);
                    }
                }
                
                if (currentTool === 'select') {
                    // Don't select when clicking on transformer
                    if (e.target.getParent() && e.target.getParent().className === 'Transformer') {
                        return;
                    }
                    
                    // Select the shape
                    try {
                        console.log("Selecting shape:", e.target);
                        transformer.nodes([e.target]);
                        selectedShape = e.target;
                        layer.draw();
                    } catch (error) {
                        console.error("Error selecting shape:", error);
                        // Reset transformer if there's an error
                        transformer.nodes([]);
                        selectedShape = null;
                        layer.draw();
                    }
                }
            });
            
            // Add drawing-specific event handlers that work alongside stage dragging
            // We'll use different event names to avoid conflicts
            stage.on('mousedown.draw', function(e) {
                console.log("Drawing mouse down, current tool:", currentTool, "isEditMode:", isEditMode);
                
                // Only handle drawing if we're in edit mode and using a drawing tool
                if (currentTool === 'select' || !isEditMode) return;
                
                // Don't start drawing if we're clicking on a shape (let the stage dragging handle it)
                if (e.target !== stage && e.target !== layer) return;
                
                isDrawing = true;
                const pos = stage.getPointerPosition();
                startX = pos.x;
                startY = pos.y;
                
                try {
                    if (currentTool === 'rectangle') {
                        console.log("Creating rectangle at", startX, startY);
                        // Create new rectangle
                        selectedShape = new Konva.Rect({
                            x: startX,
                            y: startY,
                            width: 0,
                            height: 0,
                            fill: document.getElementById('shapeColor').value,
                            stroke: '#000',
                            strokeWidth: 1,
                            draggable: true
                        });
                        
                        // Add drag handlers to prevent transformer issues
                        addDragHandlersToShape(selectedShape);
                        
                        layer.add(selectedShape);
                        konvaShapes.push(selectedShape);
                        layer.draw();
                        
                    } else if (currentTool === 'circle') {
                        // Create new circle
                        selectedShape = new Konva.Circle({
                            x: startX,
                            y: startY,
                            radius: 0,
                            fill: document.getElementById('shapeColor').value,
                            stroke: '#000',
                            strokeWidth: 1,
                            draggable: true
                        });
                        
                        // Add drag handlers to prevent transformer issues
                        addDragHandlersToShape(selectedShape);
                        
                        layer.add(selectedShape);
                        konvaShapes.push(selectedShape);
                        layer.draw();
                        
                    } else if (currentTool === 'text') {
                        // Create new text
                        const textContent = prompt("Enter text:", "Text");
                        if (textContent) {
                            selectedShape = new Konva.Text({
                                x: startX,
                                y: startY,
                                text: textContent,
                                fontSize: 20,
                                fill: document.getElementById('shapeColor').value,
                                draggable: true
                            });
                            
                            // Add drag handlers to prevent transformer issues
                            addDragHandlersToShape(selectedShape);
                            
                            layer.add(selectedShape);
                            konvaShapes.push(selectedShape);
                            
                            // Select the new text
                            transformer.nodes([selectedShape]);
                            
                            // Switch to select tool immediately after placing text
                            setTimeout(function() {
                                selectTool('select');
                            }, 10);
                            
                            layer.draw();
                        }
                        isDrawing = false;
                    }
                } catch (error) {
                    console.error("Error creating shape:", error);
                    isDrawing = false;
                    selectedShape = null;
                }
            });
            
            // Handle mouse move for drawing
            stage.on('mousemove.draw', function(e) {
                if (!isDrawing || !selectedShape) return;
                
                const pos = stage.getPointerPosition();
                
                try {
                    if (currentTool === 'rectangle' && selectedShape instanceof Konva.Rect) {
                        const width = pos.x - startX;
                        const height = pos.y - startY;
                        
                        selectedShape.width(width);
                        selectedShape.height(height);
                        layer.batchDraw();
                        
                    } else if (currentTool === 'circle' && selectedShape instanceof Konva.Circle) {
                        const dx = pos.x - startX;
                        const dy = pos.y - startY;
                        const radius = Math.sqrt(dx * dx + dy * dy);
                        
                        selectedShape.radius(radius);
                        layer.batchDraw();
                    }
                } catch (error) {
                    console.error("Error updating shape:", error);
                    isDrawing = false;
                }
            });
            
            // Handle mouse up for finishing drawing
            stage.on('mouseup.draw', function() {
                console.log("Drawing mouse up detected, isDrawing:", isDrawing, "currentTool:", currentTool);
                
                // Only handle shape completion if we're in drawing mode
                if (!isDrawing) return;
                
                // Reset drawing state first
                isDrawing = false;
                
                // Handle completed shape
                if (selectedShape) {
                    try {
                        // Check if we should keep the shape based on its size
                        let shouldKeepShape = true;
                        
                        if (selectedShape instanceof Konva.Rect && 
                            (Math.abs(selectedShape.width()) < 5 || Math.abs(selectedShape.height()) < 5)) {
                            shouldKeepShape = false;
                        } else if (selectedShape instanceof Konva.Circle && selectedShape.radius() < 5) {
                            shouldKeepShape = false;
                        }
                        
                        if (!shouldKeepShape) {
                            // Remove shapes that are too small
                            selectedShape.remove();
                            const index = konvaShapes.indexOf(selectedShape);
                            if (index > -1) {
                                konvaShapes.splice(index, 1);
                            }
                            selectedShape = null;
                        } else {
                            // Select the shape we just drew
                            transformer.nodes([selectedShape]);
                        }
                        
                        // Switch to select tool only if we were using a drawing tool
                        // This ensures delete tool stays active
                        if (['rectangle', 'circle', 'text'].includes(currentTool)) {
                            setTimeout(function() {
                                selectTool('select');
                            }, 10);
                        }
                        
                        layer.draw();
                    } catch (error) {
                        console.error("Error finalizing shape:", error);
                        // Reset state on error
                        selectedShape = null;
                        selectTool('select');
                        layer.draw();
                    }
                } else {
                    // Even if there's no selected shape, still switch to select tool if using drawing tools
                    if (['rectangle', 'circle', 'text'].includes(currentTool)) {
                        selectTool('select');
                    }
                }
            });
            
            console.log("Konva event handlers set up");
        }

        // Helper function to add consistent drag handlers to all shapes
        function addDragHandlersToShape(shape) {
            // Clear any existing handlers to prevent duplicates
            shape.off('dragstart');
            shape.off('dragend');
            
            shape.on('dragstart', function() {
                console.log('Drag started on shape', shape);
                // Remove the transformer during drag to prevent errors
                transformer.nodes([]);
            });
            
            shape.on('dragend', function() {
                console.log('Drag ended on shape', shape, 'current tool:', currentTool);
                // Only add the transformer back if still in select mode
                if (currentTool === 'select') {
                    transformer.nodes([shape]);
                    selectedShape = shape;
                    layer.draw();
                }
            });
            
            // Make sure the shape is clickable
            shape.listening(true);
        }

        function closeFloorPlan() {
            const modal = document.getElementById('floorPlanModal');
            modal.style.display = 'none';
        }

        async function loadFloorPlan(locationId) {
            try {
                console.log('Loading floor plan for location:', locationId);
                
                // Load floor plan data from IndexedDB
                const floorPlan = await db.get('floorPlans', locationId);
                
                if (floorPlan) {
                    console.log('Floor plan data loaded:', floorPlan);
                    shapes = floorPlan.shapes || [];
                    placedProducts = floorPlan.placedProducts || [];
                    
                    // Clear Konva shapes
                    konvaShapes = [];
                    layer.destroyChildren();
                    
                    // Add transformer back
                    layer.add(transformer);
                    
                    // Create Konva shapes from saved data
                    shapes.forEach(shape => {
                        let konvaShape;
                        
                        if (shape.type === 'rectangle') {
                            konvaShape = new Konva.Rect({
                                x: shape.x,
                                y: shape.y,
                                width: shape.width,
                                height: shape.height,
                                fill: shape.fill,
                                stroke: '#000',
                                strokeWidth: 1,
                                draggable: true
                            });
                        } else if (shape.type === 'circle') {
                            konvaShape = new Konva.Circle({
                                x: shape.x,
                                y: shape.y,
                                radius: shape.radius,
                                fill: shape.fill,
                                stroke: '#000',
                                strokeWidth: 1,
                                draggable: true
                            });
                        } else if (shape.type === 'text') {
                            konvaShape = new Konva.Text({
                                x: shape.x,
                                y: shape.y,
                                text: shape.text,
                                fontSize: 20,
                                fill: shape.fill,
                                draggable: true
                            });
                        }
                        
                        if (konvaShape) {
                            layer.add(konvaShape);
                            konvaShapes.push(konvaShape);
                        }
                    });
                    
                    // Add placed products
                    const placedProductsContainer = document.getElementById('placedProducts');
                    placedProductsContainer.innerHTML = '';
                    
                    placedProducts.forEach(product => {
                        const productText = new Konva.Text({
                            x: product.x,
                            y: product.y,
                            text: product.name,
                            fontSize: 14,
                            padding: 5,
                            fill: '#ffffff',
                            draggable: true,
                            id: 'product-' + product.productId
                        });
                        
                        const productBox = new Konva.Rect({
                            x: product.x,
                            y: product.y,
                            width: productText.width(),
                            height: productText.height(),
                            fill: '#2196F3',
                            opacity: 0.7,
                            cornerRadius: 3,
                            draggable: true
                        });
                        
                        // Group product text and box
                        const productGroup = new Konva.Group({
                            draggable: true,
                            productId: product.productId
                        });
                        
                        productGroup.add(productBox);
                        productGroup.add(productText);
                        layer.add(productGroup);
                    });
                    
                    layer.draw();
                } else {
                    console.log('No floor plan found for location:', locationId);
                    // Create empty floor plan
                    shapes = [];
                    placedProducts = [];
                    layer.draw();
                }
            } catch (error) {
                console.error('Error loading floor plan:', error);
                alert('Error loading floor plan: ' + error.message);
                shapes = [];
                placedProducts = [];
                layer.draw();
            }
        }

        async function saveFloorPlan() {
            try {
                // Export Konva shapes to simple objects
                shapes = konvaShapes.map(shape => {
                    const baseShape = {
                        x: shape.x(),
                        y: shape.y(),
                        fill: shape.fill()
                    };
                    
                    if (shape instanceof Konva.Rect) {
                        return {
                            ...baseShape,
                            type: 'rectangle',
                            width: shape.width(),
                            height: shape.height()
                        };
                    } else if (shape instanceof Konva.Circle) {
                        return {
                            ...baseShape,
                            type: 'circle',
                            radius: shape.radius()
                        };
                    } else if (shape instanceof Konva.Text) {
                        return {
                            ...baseShape,
                            type: 'text',
                            text: shape.text()
                        };
                    }
                    
                    return null;
                }).filter(Boolean);
                
                // Get product groups and export their data
                placedProducts = [];
                layer.find('.Group').forEach(group => {
                    if (group.attrs.productId) {
                        placedProducts.push({
                            productId: group.attrs.productId,
                            name: group.findOne('Text').text(),
                            x: group.x(),
                            y: group.y()
                        });
                    }
                });
                
                // Create floor plan object
                const floorPlan = {
                    locationId: currentLocation,
                    shapes: shapes,
                    placedProducts: placedProducts
                };
                
                console.log('Saving floor plan:', floorPlan);
                
                // Save to IndexedDB
                await db.put('floorPlans', floorPlan);
                
                // Verify the save by reading it back
                const savedPlan = await db.get('floorPlans', currentLocation);
                if (savedPlan) {
                    console.log('Floor plan saved and verified:', savedPlan);
                    alert('Floor plan saved successfully!');
                } else {
                    throw new Error('Floor plan was not saved correctly');
                }
            } catch (error) {
                console.error('Error saving floor plan:', error);
                alert('Error saving floor plan: ' + error.message);
            }
        }

        function selectTool(tool) {
            currentTool = tool;
            
            console.log("Tool selected:", tool);
            
            // Update active button and canvas cursor
            document.querySelectorAll('.shape-button').forEach(button => {
                if (button.dataset.tool === tool) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
                
                // Reset any special class
                button.classList.remove('delete-tool');
            });
            
            // Set special styling for delete tool
            if (tool === 'delete') {
                document.querySelector('[data-tool="delete"]').classList.add('delete-tool');
                stage.container().classList.add('delete-cursor');
            } else {
                stage.container().classList.remove('delete-cursor');
            }
            
            // Clear selection when changing tools (except for select tool)
            if (tool !== 'select' && transformer) {
                transformer.nodes([]);
                selectedShape = null;
                layer.draw();
            }
        }

        function deleteSelected() {
            if (!selectedShape) return;
            
            try {
                // First remove from transformer to prevent errors
                transformer.nodes([]);
                
                // Remove from konvaShapes array if it's a basic shape
                const index = konvaShapes.indexOf(selectedShape);
                if (index > -1) {
                    konvaShapes.splice(index, 1);
                }
                
                // If it's a product group, remove from placedProducts
                if (selectedShape instanceof Konva.Group && selectedShape.attrs.productId) {
                    const productId = selectedShape.attrs.productId;
                    placedProducts = placedProducts.filter(p => p.productId !== productId);
                }
                
                // Remove the shape from the layer
                selectedShape.destroy();
                selectedShape = null;
                
                // Redraw the layer
                layer.draw();
                
                console.log("Shape deleted successfully");
            } catch (error) {
                console.error("Error deleting shape:", error);
                // Reset the state
                transformer.nodes([]);
                selectedShape = null;
                layer.draw();
            }
        }

        function clearFloorPlan() {
            if (confirm('Are you sure you want to clear the entire floor plan?')) {
                konvaShapes = [];
                layer.destroyChildren();
                layer.add(transformer);
                layer.draw();
                shapes = [];
                placedProducts = [];
            }
        }

        function loadProductsForPlacement() {
            const productList = document.getElementById('productList');
            productList.innerHTML = '';
            
            // Get products with inventory in this location
            const productsInLocation = inventoryItems
                .filter(item => item.locationId === currentLocation && item.quantity > 0)
                .map(item => {
                    const product = products.find(p => p.id === item.productId);
                    return product ? {
                        id: product.id,
                        name: product.name,
                        quantity: item.quantity
                    } : null;
                })
                .filter(Boolean);
            
            productsInLocation.forEach(product => {
                const productItem = document.createElement('div');
                productItem.className = 'product-item';
                productItem.innerHTML = `
                    <span>${product.name}</span>
                    <span>(Qty: ${product.quantity})</span>
                `;
                productItem.dataset.productId = product.id;
                productItem.dataset.productName = product.name;
                
                productItem.draggable = true;
                productItem.addEventListener('dragstart', onDragStart);
                
                productList.appendChild(productItem);
            });
            
            // Make canvas container droppable
            const canvasContainer = document.querySelector('.floor-plan-canvas-container');
            canvasContainer.addEventListener('dragover', onDragOver);
            canvasContainer.addEventListener('drop', onDrop);
        }

        function onDragStart(e) {
            e.dataTransfer.setData('productId', e.target.dataset.productId);
            e.dataTransfer.setData('productName', e.target.dataset.productName);
        }
        
        function onDragOver(e) {
            e.preventDefault();
        }
        
        function onDrop(e) {
            e.preventDefault();
            
            const productId = e.dataTransfer.getData('productId');
            const productName = e.dataTransfer.getData('productName');
            
            if (!productId || !productName) {
                console.error("Missing product data in drop event");
                return;
            }
            
            try {
                // Get position relative to the canvas container
                const rect = stage.container().getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                console.log("Dropping product at position:", x, y);
                
                // Create product text
                const productText = new Konva.Text({
                    x: 0,
                    y: 0,
                    text: productName,
                    fontSize: 14,
                    padding: 5,
                    fill: '#ffffff'
                });
                
                // Create product background
                const productBox = new Konva.Rect({
                    x: 0,
                    y: 0,
                    width: productText.width(),
                    height: productText.height(),
                    fill: '#2196F3',
                    opacity: 0.7,
                    cornerRadius: 3
                });
                
                // Group product text and box
                const productGroup = new Konva.Group({
                    x: x,
                    y: y,
                    draggable: true,
                    name: 'productGroup',
                    productId: productId
                });
                
                productGroup.add(productBox);
                productGroup.add(productText);
                
                // Make sure the group is recognized as a shape for selection and dragging
                productGroup.listening(true);
                
                // Add custom drag events to prevent transformer errors
                productGroup.off('dragstart'); // Clear any existing handlers
                productGroup.off('dragend');
                
                productGroup.on('dragstart', function() {
                    console.log('Product drag started');
                    // Remove the transformer during drag to prevent errors
                    transformer.nodes([]);
                });
                
                productGroup.on('dragend', function() {
                    console.log('Product drag ended, current tool:', currentTool);
                    
                    // Only add the transformer back if in select mode
                    if (currentTool === 'select') {
                        transformer.nodes([productGroup]);
                        selectedShape = productGroup;
                    }
                    
                    // Update product position in placedProducts array
                    const product = placedProducts.find(p => p.productId === productId);
                    if (product) {
                        product.x = productGroup.x();
                        product.y = productGroup.y();
                    }
                    
                    layer.draw();
                });
                
                // Add to layer and draw
                layer.add(productGroup);
                
                // Select the newly created product if in select mode
                if (currentTool === 'select') {
                    transformer.nodes([productGroup]);
                    selectedShape = productGroup;
                } else if (currentTool !== 'delete') {
                    // Switch to select tool if not in delete mode
                    selectTool('select');
                }
                
                layer.draw();
                
                console.log("Product placed:", productName, "at", x, y);
                
                // Add to placedProducts array
            placedProducts.push({
                productId: productId,
                name: productName,
                x: x,
                y: y
            });
            } catch (error) {
                console.error("Error placing product:", error);
            }
        }

        function viewFloorPlan() {
            // Toggle edit mode
            isEditMode = !isEditMode;
            
            // Update UI
            const editElements = document.querySelectorAll('.floor-plan-tools, .product-placement-panel');
            editElements.forEach(el => {
                el.style.display = isEditMode ? 'flex' : 'none';
            });
            
            document.querySelector('.floor-plan-actions').innerHTML = isEditMode
                ? `<button onclick="saveFloorPlan()">Save Floor Plan</button>
                   <button onclick="viewFloorPlan()">View Mode</button>`
                : `<button onclick="viewFloorPlan()">Edit Mode</button>
                   <button onclick="closeFloorPlan()">Close</button>`;
            
            try {
                // Remove transformer when switching to view mode
                if (!isEditMode) {
                    transformer.nodes([]);
                    selectedShape = null;
                    document.body.style.cursor = 'grab';
                } else {
                    document.body.style.cursor = 'default';
                }
                
                // Update Konva shapes and product groups
                konvaShapes.forEach(shape => {
                    if (shape && typeof shape.draggable === 'function') {
                        shape.draggable(isEditMode);
                    }
                });
                
                // Update product groups
                layer.find('.Group').forEach(group => {
                    if (group && typeof group.draggable === 'function') {
                        group.draggable(isEditMode);
                    }
                });
                
                // Toggle transformer visibility
                transformer.visible(isEditMode);
                
                layer.draw();
            } catch (error) {
                console.error("Error updating view mode:", error);
            }
        }

        function changeUser(selectedUserId) {
            if (!selectedUserId && users.length > 0) {
                // If somehow no user is selected, select the first one
                selectedUserId = users[0].id;
                document.getElementById('userSelect').value = selectedUserId;
            }
            currentUserId = selectedUserId;
            currentUser = users.find(user => user.id === selectedUserId)?.name || '';
            updateTable();
        }
        
        async function renameUser() {
            const userSelect = document.getElementById('userSelect');
            const selectedUserName = userSelect.value;
            const selectedUser = users.find(user => user.name === selectedUserName);
            
            if (!selectedUser) return;
            
            const newName = prompt("Enter new name for " + selectedUserName + ":", selectedUserName);
            
            if (newName && newName.trim() !== "") {
                // Update option text
                const selectedOption = userSelect.options[userSelect.selectedIndex];
                selectedOption.text = newName;
                selectedOption.value = newName;
                
                // Update in users array
                selectedUser.name = newName;
                
                // Update current user
                currentUser = newName;
                
                // Update in history
                updateUserInHistory(selectedUserName, newName);
                
                // Save to IndexedDB
                await saveToIndexedDB('users', users);
                
                console.log('User renamed from', selectedUserName, 'to', newName);
            }
        }
        
        async function addUser() {
            const userSelect = document.getElementById('userSelect');
            const newName = prompt("Enter name for new user:", "");
            
            if (newName && newName.trim() !== "") {
                // Create new user object
                const newUser = {
                    id: 'user-' + Date.now(),
                    name: newName
                };
                
                // Add to users array
                users.push(newUser);
                
                // Create new option
                const option = document.createElement('option');
                option.text = newName;
                option.value = newName;
                userSelect.add(option);
                
                // Select the new user
                userSelect.value = newName;
                currentUser = newName;
                currentUserId = newUser.id;
                
                // Save to IndexedDB
                await saveToIndexedDB('users', users);
                
                console.log('New user added:', newName, '(ID:', newUser.id, ')');
            }
        }
        
        async function deleteUser() {
            const userSelect = document.getElementById('userSelect');
            
            // Prevent deleting if only one user remains
            if (userSelect.options.length <= 1) {
                alert("Cannot delete the last user.");
                return;
            }
            
            const selectedUserName = userSelect.value;
            const userIndex = users.findIndex(user => user.name === selectedUserName);
            
            if (userIndex === -1) return;
            
            if (confirm("Are you sure you want to delete user: " + selectedUserName + "?")) {
                // Remove from users array
                users.splice(userIndex, 1);
                
                // Remove the selected option
                userSelect.remove(userSelect.selectedIndex);
                
                // Update current user to the first available
                currentUser = userSelect.value;
                const newSelectedUser = users.find(user => user.name === currentUser);
                if (newSelectedUser) {
                    currentUserId = newSelectedUser.id;
                }
                
                // Save to IndexedDB
                await saveToIndexedDB('users', users);
                
                console.log('User deleted:', selectedUserName);
            }
        }
        
        function updateUserInHistory(oldName, newName) {
            // Update username in transaction history
            for (const transaction of transactions) {
                if (transaction.user === oldName) {
                    transaction.user = newName;
                }
            }
            
            // Update the display
            updateHistory();
            
            // Save changes
            save();
        }
        
        async function loadUsers() {
            try {
                users = await loadFromIndexedDB('users') || [];
                const userSelect = document.getElementById('userSelect');
                
                // Only update the user selector if it exists
                if (userSelect) {
                    userSelect.innerHTML = '';
                    users.forEach(user => {
                        const option = document.createElement('option');
                        option.value = user.id;
                        option.textContent = user.name;
                        if (user.id === currentUserId) {
                            option.selected = true;
                        }
                        userSelect.appendChild(option);
                    });

                    // If no user is selected, select the first one
                    if (!currentUserId && users.length > 0) {
                        currentUserId = users[0].id;
                        currentUser = users[0].name;
                        userSelect.value = currentUserId;
                    }
                }
                
                // Update the table to reflect any user changes
                updateTable();
            } catch (error) {
                console.error('Error loading users:', error);
            }
        }

        // Export/Import Functions
        async function exportData() {
            try {
                // Collect all data from IndexedDB
                const exportData = {
                    products: await loadFromIndexedDB('products') || [],
                    locations: await loadFromIndexedDB('locations') || [],
                    inventory: await loadFromIndexedDB('inventory') || [],
                    transactions: await loadFromIndexedDB('transactions') || [],
                    users: await loadFromIndexedDB('users') || [],
                    floorPlans: await loadFromIndexedDB('floorPlans') || [],
                    exportDate: new Date().toISOString(),
                    appVersion: '1.0.0'
                };
                
                // Convert to JSON string
                const jsonData = JSON.stringify(exportData, null, 2);
                
                // Create blob and download link
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Format date for filename
                const date = new Date();
                const dateStr = date.toISOString().split('T')[0];
                
                // Create download link
                const a = document.createElement('a');
                a.href = url;
                a.download = `inventory_export_${dateStr}.json`;
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
                
                console.log('Data exported successfully');
            } catch (error) {
                console.error('Error exporting data:', error);
                alert('Error exporting data: ' + error.message);
            }
        }
        
        function importData() {
            // Trigger file input click
            const importFile = document.getElementById('settingsImportFile');
            if (importFile) {
                importFile.click();
            } else {
                console.error('Import file input not found');
                alert('Error: Import functionality not available');
            }
        }
        
        async function handleImportFile(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;
                
                // Confirm before importing
                if (!confirm('Importing data will replace all current data. Continue?')) {
                    event.target.value = null;
                    return;
                }
                
                // Start import immediately after confirmation
                const reader = new FileReader();
                
                reader.onload = async (e) => {
                    try {
                        // Parse JSON data
                        const importData = JSON.parse(e.target.result);
                        
                        // Validate data structure
                        if (!importData.products || !importData.locations || !importData.inventory) {
                            throw new Error('Invalid import file format');
                        }
                        
                        // Import each store
                        if (importData.products && Array.isArray(importData.products)) {
                            await saveToIndexedDB('products', importData.products);
                            products = importData.products;
                        }
                        
                        if (importData.locations && Array.isArray(importData.locations)) {
                            await saveToIndexedDB('locations', importData.locations);
                            locations = importData.locations;
                        }
                        
                        if (importData.inventory && Array.isArray(importData.inventory)) {
                            await saveToIndexedDB('inventory', importData.inventory);
                            inventoryItems = importData.inventory;
                        }
                        
                        if (importData.transactions && Array.isArray(importData.transactions)) {
                            await saveToIndexedDB('transactions', importData.transactions);
                            transactions = importData.transactions;
                        }
                        
                        if (importData.users && Array.isArray(importData.users)) {
                            await saveToIndexedDB('users', importData.users);
                            users = importData.users;
                        }
                        
                        if (importData.floorPlans && Array.isArray(importData.floorPlans)) {
                            // Clear existing floor plans
                            const tx = db.transaction('floorPlans', 'readwrite');
                            await tx.objectStore('floorPlans').clear();
                            await tx.done;
                            
                            // Import floor plans
                            for (const floorPlan of importData.floorPlans) {
                                await db.put('floorPlans', floorPlan);
                            }
                        }
                        
                        // Set current location to first available
                        if (locations.length > 0) {
                            currentLocation = locations[0].id;
                        }
                        
                        // Update UI
                        await loadUsers();
                        updateLocationSelect();
                        updateTable();
                        updateHistory();
                        
                        console.log('Data imported successfully');
                        alert('Data imported successfully!');
                        
                        // Close settings modal if it's open
                        closeSettings();
                    } catch (error) {
                        console.error('Error parsing import file:', error);
                        alert('Error importing data: ' + error.message);
                    }
                };
                
                reader.onerror = () => {
                    console.error('Error reading file');
                    alert('Error reading file');
                };
                
                reader.readAsText(file);
                
                // Reset file input
                event.target.value = null;
            } catch (error) {
                console.error('Error handling import file:', error);
                alert('Error handling import file: ' + error.message);
            }
        }

        // Add ESC key support for settings modal
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                const settingsModal = document.getElementById('settingsModal');
                if (settingsModal.style.display === 'block') {
                    closeSettings();
                } else {
                    openSettings();
                }
            }
        });

        // Barcode Scanner Variables
        let scannerStream = null;
        let scannerInterval = null;
        let currentCameraIndex = 0;
        let availableCameras = [];
        
        
        // Store the ZXing reader instance
        let codeReader = null;
        
        // Look up a product by barcode
        function lookupProductByBarcode(barcode) {
            // In a real implementation, you would look up the product in your database
            // For now, we'll just search for a product with a matching ID
            
            const product = products.find(p => p.id === barcode || p.barcode === barcode);
            
            if (product) {
                // Product found, scroll to it in the table
                const productRow = document.querySelector(`tr[data-product-id="${product.id}"]`);
                if (productRow) {
                    productRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    productRow.classList.add('highlight-row');
                    setTimeout(() => {
                        productRow.classList.remove('highlight-row');
                    }, 2000);
                }
                
                // Add to history
                addToHistory({
                    type: 'scan_barcode',
                    productId: product.id,
                    productName: product.name,
                    barcode: barcode,
                    timestamp: new Date().toISOString()
                });
            } else {
                // Product not found, ask if user wants to add it
                if (confirm(`No product found with barcode ${barcode}. Would you like to add it?`)) {
                    // Pre-fill the add item form
                    document.getElementById('itemName').value = `Product ${barcode}`;
                    document.getElementById('itemQuantity').value = '1';
                    document.getElementById('itemPrice').value = '0.00';
                    
                    // Focus on the name field for editing
                    document.getElementById('itemName').focus();
                }
            }
        }
        
        // Add this to the style section
        document.head.insertAdjacentHTML('beforeend', `
            <style>
                .highlight-row {
                    animation: highlight 2s ease-out;
                }
                
                @keyframes highlight {
                    0% { background-color: rgba(255, 255, 0, 0.5); }
                    100% { background-color: transparent; }
                }
            </style>
        `);

        // Add barcode assignment functions
        let currentBarcodeProductId = null;
        let currentScannedBarcode = null;
        
        function openBarcodeModal(productId) {
            const product = products.find(p => p.id === productId);
            if (!product) return;
            
            currentBarcodeProductId = productId;
            document.getElementById('barcodeProductName').textContent = product.name;
            document.getElementById('barcodeInput').value = product.barcode || '';
            document.getElementById('barcodeModal').style.display = 'block';
            document.getElementById('barcodeInput').focus();
        }

        function showBarcodeAssignmentModal(barcode) {
            // Create a select dropdown with all products
            const modal = document.getElementById('assignBarcodeModal') || createAssignBarcodeModal();
            const productSelect = document.getElementById('assignBarcodeProductSelect');
            
            // Clear previous options
            productSelect.innerHTML = '';
            
            // Add options for all products without barcodes
            products.forEach(product => {
                const option = document.createElement('option');
                option.value = product.id;
                option.textContent = product.name;
                productSelect.appendChild(option);
            });
            
            // Set the scanned barcode
            currentScannedBarcode = barcode;
            document.getElementById('assignBarcodeValue').textContent = barcode;
            
            // Show modal
            modal.style.display = 'block';
        }

        function createAssignBarcodeModal() {
            // Create modal if it doesn't exist
            const modal = document.createElement('div');
            modal.id = 'assignBarcodeModal';
            modal.className = 'modal';
            
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Assign Barcode</h2>
                        <span class="close" onclick="closeAssignBarcodeModal()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <p>Barcode: <strong id="assignBarcodeValue"></strong></p>
                        <p>Select product to assign this barcode to:</p>
                        <select id="assignBarcodeProductSelect" class="form-control"></select>
                    </div>
                    <div class="modal-footer">
                        <button onclick="assignBarcodeToExistingProduct()">Assign Barcode</button>
                        <button onclick="closeAssignBarcodeModal()">Cancel</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            return modal;
        }

        function closeAssignBarcodeModal() {
            const modal = document.getElementById('assignBarcodeModal');
            if (modal) modal.style.display = 'none';
            currentScannedBarcode = null;
        }

        async function assignBarcodeToExistingProduct() {
            const productId = document.getElementById('assignBarcodeProductSelect').value;
            const product = products.find(p => p.id === productId);
            
            if (!product || !currentScannedBarcode) return;
            
            // Update the product barcode
            const oldBarcode = product.barcode || '';
            product.barcode = currentScannedBarcode;
            
            // Add to history
            await addToHistory({
                type: 'assign_barcode',
                productId: product.id,
                productName: product.name,
                oldValue: oldBarcode,
                newValue: currentScannedBarcode,
                timestamp: new Date().toISOString()
            });
            
            // Save to database
            await save();
            
            // Close modal
            closeAssignBarcodeModal();
            closeBarcodeScanner();
            
            // Show success message
            alert(`Barcode ${currentScannedBarcode} assigned to ${product.name}`);
            
            // Update UI
            updateTable();
        }

        async function assignBarcodeToNewProduct(barcode) {
            // Pre-fill the item form
            document.getElementById('itemName').value = `Product ${barcode}`;
            document.getElementById('itemQuantity').value = '1';
            document.getElementById('itemPrice').value = '0.00';
            
            // Close barcode scanner
            closeBarcodeScanner();
            
            // Focus on the name field
            document.getElementById('itemName').focus();
            
            // Create a new product with the barcode
            const product = { 
                id: Date.now().toString(),
                name: `Product ${barcode}`,
                price: 0,
                comments: '',
                barcode: barcode,
            };
            
            // Add to products array
            products.push(product);
            
            // Add to history
            await addToHistory({
                type: 'create_product',
                productId: product.id,
                productName: product.name,
                barcode: barcode,
                timestamp: new Date().toISOString()
            });
            
            // Save to database
            await save();
            
            // Update UI
            updateTable();
            
            // Show success message
            alert(`New product created with barcode ${barcode}. Please update the details.`);
        }
        
        function closeBarcodeModal() {
            document.getElementById('barcodeModal').style.display = 'none';
            currentBarcodeProductId = null;
        }
        
        // Function to scan a barcode for a product
        function scanBarcodeForProduct() {
            // Close the barcode modal temporarily
            document.getElementById('barcodeModal').style.display = 'none';
            
            // Remember that we're scanning for a product
            const scanningForProduct = true;
            const productId = currentBarcodeProductId;
            
            // Show the scanner modal
            document.getElementById('scannerModal').style.display = 'block';
            
            // Reset the results
            document.getElementById('scannerResult').textContent = '';
            document.getElementById('productResult').textContent = '';
            
            // Get video element
            const videoElement = document.getElementById('video');
            
            // Create instance of the reader
            codeReader = new window.BrowserMultiFormatReader();
            
            // Get available video devices
            codeReader.listVideoInputDevices()
                .then(videoInputDevices => {
                    if (videoInputDevices.length === 0) {
                        alert('No camera devices found');
                        cancelBarcodeScanning();
                        return;
                    }
                    
                    // Use first device by default
                    const firstDeviceId = videoInputDevices[0].deviceId;
                    
                    // Start decoding from video device
                    codeReader.decodeFromVideoDevice(firstDeviceId, videoElement, (result, error) => {
                        if (result) {
                            // Barcode found!
                            const barcode = result.getText();
                            document.getElementById('scannerResult').textContent = `Found barcode: ${barcode}`;
                            
                            // Check if the barcode is already assigned to a different product
                            const existingProduct = products.find(p => p.barcode === barcode && p.id !== productId);
                            if (existingProduct) {
                                document.getElementById('productResult').innerHTML = `
                                    <div class="alert alert-warning mt-3">
                                        <p>Barcode ${barcode} is already assigned to product "${existingProduct.name}"</p>
                                        <button class="btn btn-primary" onclick="useScannedBarcodeForProduct('${barcode}')">Use Anyway</button>
                                        <button class="btn btn-secondary" onclick="cancelBarcodeScanning()">Cancel</button>
                                    </div>
                                `;
                            } else {
                                // Use the barcode for the current product
                                useScannedBarcodeForProduct(barcode);
                            }
                        }
                        
                        if (error && !(error instanceof window.NotFoundException)) {
                            // Only log critical errors, not the common "not found" errors
                            console.error('ZXing error:', error);
                        }
                    });
                })
                .catch(err => {
                    console.error('Error accessing camera:', err);
                    alert('Error accessing camera: ' + err);
                    cancelBarcodeScanning();
                });
        }
        
        // Function to use a scanned barcode for a product
        function useScannedBarcodeForProduct(barcode) {
            // Close the scanner
            closeBarcodeScanner();
            
            // Reopen the barcode modal
            document.getElementById('barcodeModal').style.display = 'block';
            
            // Set the scanned barcode value in the input field
            document.getElementById('barcodeInput').value = barcode;
            
            // Focus on the save button
            setTimeout(() => {
                const saveButton = document.querySelector('.barcode-form .save-btn');
                if (saveButton) saveButton.focus();
            }, 100);
        }
        
        // Function to cancel barcode scanning and go back to the barcode modal
        function cancelBarcodeScanning() {
            // Close the scanner
            closeBarcodeScanner();
            
            // Reopen the barcode modal
            document.getElementById('barcodeModal').style.display = 'block';
        }
        
        async function saveBarcode() {
            if (!currentBarcodeProductId) return;
            
            const barcode = document.getElementById('barcodeInput').value.trim();
            const product = products.find(p => p.id === currentBarcodeProductId);
            
            if (!product) return;
            
            // Check if barcode already exists on another product
            const existingProduct = products.find(p => p.barcode === barcode && p.id !== currentBarcodeProductId);
            if (barcode && existingProduct) {
                if (!confirm(`This barcode is already assigned to product "${existingProduct.name}". Do you want to reassign it?`)) {
                    return;
                }
                
                // Remove barcode from existing product
                const oldBarcode = existingProduct.barcode;
                existingProduct.barcode = '';
                
                // Add to history
                await addToHistory({
                    type: 'remove_barcode',
                    productId: existingProduct.id,
                    productName: existingProduct.name,
                    oldValue: oldBarcode,
                    newValue: '',
                    timestamp: new Date().toISOString()
                });
            }
            
            const oldBarcode = product.barcode || '';
            product.barcode = barcode;
            
            await addToHistory({
                type: 'assign_barcode',
                productId: product.id,
                productName: product.name,
                oldValue: oldBarcode,
                newValue: barcode,
                timestamp: new Date().toISOString()
            });
            
            await save();
            closeBarcodeModal();
            updateTable();
        }

        // Settings Functions
        function openSettings() {
            const modal = document.getElementById('settingsModal');
            modal.style.display = 'block';
            
            // Update theme toggle state
            document.getElementById('settingsThemeCheckbox').checked = currentTheme === 'dark';
            
            // Load users and locations lists
            updateUsersList();
            updateLocationsList();
            
            // Add click outside listener to close settings
            window.addEventListener('click', closeSettingsOnClickOutside);
        }
        
        function closeSettings() {
            const modal = document.getElementById('settingsModal');
            modal.style.display = 'none';
            
            // Remove the click outside listener
            window.removeEventListener('click', closeSettingsOnClickOutside);
        }
        
        // Function to handle clicking outside the settings modal
        function closeSettingsOnClickOutside(event) {
            const modal = document.getElementById('settingsModal');
            const content = document.querySelector('.settings-content');
            
            // If the click is on the modal background (not on the content)
            if (event.target === modal) {
                closeSettings();
            }
        }
        
        function switchSettingsTab(tabName) {
            // Hide all panels
            document.querySelectorAll('.settings-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Deactivate all tabs
            document.querySelectorAll('.settings-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected panel
            document.getElementById(tabName + 'Settings').classList.add('active');
            
            // Activate selected tab
            document.querySelector(`.settings-tab[onclick="switchSettingsTab('${tabName}')"]`).classList.add('active');
        }
        
        function updateUsersList() {
            const usersList = document.getElementById('usersList');
            usersList.innerHTML = '';
            
            users.forEach(user => {
                const listItem = document.createElement('div');
                listItem.className = 'settings-list-item';
                
                const isCurrentUser = user.name === currentUser;
                
                listItem.innerHTML = `
                    <span>${user.name}${isCurrentUser ? ' (Current)' : ''}</span>
                    <div class="item-actions">
                        ${!isCurrentUser ? `
                            <button onclick="renameUserFromSettings('${user.id}')">Rename</button>
                            <button onclick="deleteUserFromSettings('${user.id}')" class="danger-btn">Delete</button>
                        ` : ''}
                    </div>
                `;
                
                usersList.appendChild(listItem);
            });
        }
        
        function updateLocationsList() {
            const locationsList = document.getElementById('locationsList');
            locationsList.innerHTML = '';
            
            locations.forEach(location => {
                const listItem = document.createElement('div');
                listItem.className = 'settings-list-item';
                
                const isCurrentLocation = location.id === currentLocation;
                
                listItem.innerHTML = `
                    <span>${location.name}${isCurrentLocation ? ' (Current)' : ''}</span>
                    <div class="item-actions">
                        ${!isCurrentLocation ? `
                            <button onclick="renameLocationFromSettings('${location.id}')">Rename</button>
                            <button onclick="deleteLocationFromSettings('${location.id}')" class="danger-btn">Delete</button>
                        ` : ''}
                    </div>
                `;
                
                locationsList.appendChild(listItem);
            });
        }
        
        async function addUserFromSettings() {
            const nameInput = document.getElementById('newUserName');
            const newName = nameInput.value.trim();
            
            if (!newName) {
                alert('Please enter a user name');
                return;
            }
            
            // Check if name already exists
            if (users.some(user => user.name === newName)) {
                alert('A user with this name already exists');
                return;
            }
            
            // Create new user object
            const newUser = {
                id: 'user-' + Date.now(),
                name: newName
            };
            
            // Add to users array
            users.push(newUser);
            
            // Save to IndexedDB
            await saveToIndexedDB('users', users);
            
            // Update UI
            updateUsersList();
            nameInput.value = '';
            
            // Update user dropdown
            await loadUsers();
        }
        
        async function renameUserFromSettings(userId) {
            const user = users.find(u => u.id === userId);
            if (!user) return;
            
            const newName = prompt("Enter new name for " + user.name + ":", user.name);
            
            if (newName && newName.trim() !== "") {
                // Check if name already exists
                if (users.some(u => u.id !== userId && u.name === newName)) {
                    alert('A user with this name already exists');
                    return;
                }
                
                // Update in users array
                user.name = newName;
                
                // Update current user if needed
                if (user.id === currentUserId) {
                    currentUser = newName;
                }
                
                // Update in history
                updateUserInHistory(user.name, newName);
                
                // Save to IndexedDB
                await saveToIndexedDB('users', users);
                
                // Update UI
                updateUsersList();
                
                // Update user dropdown
                await loadUsers();
            }
        }
        
        async function deleteUserFromSettings(userId) {
            const user = users.find(u => u.id === userId);
            if (!user) return;
            
            // Prevent deleting if only one user remains
            if (users.length <= 1) {
                alert("Cannot delete the last user.");
                return;
            }
            
            if (confirm("Are you sure you want to delete user: " + user.name + "?")) {
                // Remove from users array
                users = users.filter(u => u.id !== userId);
                
                // Update current user if needed
                if (userId === currentUserId) {
                    currentUser = users[0].name;
                    currentUserId = users[0].id;
                }
                
                // Save to IndexedDB
                await saveToIndexedDB('users', users);
                
                // Update UI
                updateUsersList();
                
                // Update user dropdown
                await loadUsers();
            }
        }
        
        async function addLocationFromSettings() {
            const nameInput = document.getElementById('newLocationName');
            const newName = nameInput.value.trim();
            
            if (!newName) {
                alert('Please enter a location name');
                return;
            }
            
            // Check if name already exists
            if (locations.some(loc => loc.name === newName)) {
                alert('A location with this name already exists');
                return;
            }
            
            // Create new location
            const newLocationId = String(Date.now());
            const newLocation = {
                id: newLocationId,
                name: newName
            };
            
            // Add to locations array
            locations.push(newLocation);
            
            // Save to IndexedDB
            await saveToIndexedDB('locations', locations);
            
            // Update UI
            updateLocationsList();
            nameInput.value = '';
            
            // Update location dropdown
            updateLocationSelect();
        }
        
        async function renameLocationFromSettings(locationId) {
            const location = locations.find(loc => loc.id === locationId);
            if (!location) return;
            
            const newName = prompt("Enter new name for " + location.name + ":", location.name);
            
            if (newName && newName.trim() !== "") {
                // Check if name already exists
                if (locations.some(loc => loc.id !== locationId && loc.name === newName)) {
                    alert('A location with this name already exists');
                    return;
                }
                
                const oldName = location.name;
                location.name = newName;
                
                await addToHistory({
                    type: 'rename_location',
                    locationId: locationId,
                    oldName: oldName,
                    newName: newName,
                    timestamp: new Date().toISOString()
                });
                
                // Save to IndexedDB
                await saveToIndexedDB('locations', locations);
                
                // Update UI
                updateLocationsList();
                
                // Update location dropdown
                updateLocationSelect();
            }
        }
        
        async function deleteLocationFromSettings(locationId) {
            const location = locations.find(loc => loc.id === locationId);
            if (!location) return;
            
            // Prevent deleting if only one location remains
            if (locations.length <= 1) {
                alert("Cannot delete the last location.");
                return;
            }
            
            if (confirm("Are you sure you want to delete location: " + location.name + "? All inventory items in this location will be deleted.")) {
                // Remove inventory items for this location
                inventoryItems = inventoryItems.filter(item => item.locationId !== locationId);
                
                // Remove the location
                locations = locations.filter(loc => loc.id !== locationId);
                
                // Update current location if needed
                if (locationId === currentLocation) {
                    currentLocation = locations[0].id;
                }
                
                await addToHistory({
                    type: 'delete_location',
                    location: location,
                    timestamp: new Date().toISOString()
                });
                
                // Save to IndexedDB
                await saveToIndexedDB('locations', locations);
                await saveToIndexedDB('inventory', inventoryItems);
                
                // Update UI
                updateLocationsList();
                
                // Update location dropdown
                updateLocationSelect();
                updateTable();
            }
        }
        
        async function confirmClearData() {
            if (confirm("Are you sure you want to clear all data? This action cannot be undone.")) {
                if (confirm("FINAL WARNING: All your data will be permanently deleted. Continue?")) {
                    try {
                        // Clear all object stores
                        await db.clear('products');
                        await db.clear('locations');
                        await db.clear('inventory');
                        await db.clear('transactions');
                        await db.clear('floorPlans');
                        
                        // Reset arrays
                        products = [];
                        locations = [{ id: '1', name: 'Location 1' }];
                        inventoryItems = [];
                        transactions = [];
                        currentLocation = '1';
                        
                        // Save default location
                        await saveToIndexedDB('locations', locations);
                        
                        // Update UI
                        updateLocationSelect();
                        updateTable();
                        updateHistory();
                        
                        alert('All data has been cleared. The application has been reset to default settings.');
                    } catch (error) {
                        console.error('Error clearing data:', error);
                        alert('Error clearing data: ' + error.message);
                    }
                }
            }
        }

        // Function to open scanner modal and start scanning
        function openBarcodeScanner() {
            // Reset previous results
            document.getElementById('scannerResult').textContent = '';
            document.getElementById('productResult').textContent = '';
            
            // Show the scanner modal
            document.getElementById('scannerModal').style.display = 'block';
            
            // Get video element
            const videoElement = document.getElementById('video');
            
            // Create instance of the reader
            codeReader = new window.BrowserMultiFormatReader();
            
            // Get available video devices
            codeReader.listVideoInputDevices()
                .then(videoInputDevices => {
                    if (videoInputDevices.length === 0) {
                        alert('No camera devices found');
                        closeBarcodeScanner();
                        return;
                    }
                    
                    // Use first device by default
                    const firstDeviceId = videoInputDevices[0].deviceId;
                    
                    // Start decoding from video device
                    codeReader.decodeFromVideoDevice(firstDeviceId, videoElement, (result, error) => {
                        if (result) {
                            // Barcode found!
                            const barcode = result.getText();
                            document.getElementById('scannerResult').textContent = `Found barcode: ${barcode}`;
                            
                            // Look up product by barcode
                            const product = products.find(p => p.barcode === barcode);
                            if (product) {
                                handleProductFoundByBarcode(product);
                            } else {
                                // No product found with this barcode
                                document.getElementById('productResult').innerHTML = `
                                    <div class="alert alert-warning mt-3">
                                        <p>Product with barcode ${barcode} not found</p>
                                        <button class="btn btn-primary" onclick="assignBarcodeToNewProduct('${barcode}')">Create New Product</button>
                                        <button class="btn btn-secondary" onclick="showBarcodeAssignmentModal('${barcode}')">Assign to Existing Product</button>
                                    </div>
                                `;
                            }
                        }
                        
                        if (error && !(error instanceof window.NotFoundException)) {
                            // Only log critical errors, not the common "not found" errors
                            console.error('ZXing error:', error);
                        }
                    });
                })
                .catch(err => {
                    console.error('Error accessing camera:', err);
                    alert('Error accessing camera: ' + err);
                    closeBarcodeScanner();
                });
        }

        // Function to close scanner and clean up
        function closeBarcodeScanner() {
            // Hide the scanner modal
            document.getElementById('scannerModal').style.display = 'none';
            
            // Stop the scanner if it's running
            if (codeReader) {
                codeReader.reset();
                codeReader = null;
            }
        }
        
        // Function to switch between available cameras
        function switchCamera() {
            if (!codeReader) return;
            
            // Get available cameras
            codeReader.listVideoInputDevices()
                .then(videoInputDevices => {
                    availableCameras = videoInputDevices;
                    
                    if (availableCameras.length <= 1) {
                        alert('Only one camera available');
                        return;
                    }
                    
                    // Reset the scanner
                    codeReader.reset();
                    
                    // Switch to next camera
                    currentCameraIndex = (currentCameraIndex + 1) % availableCameras.length;
                    const nextDeviceId = availableCameras[currentCameraIndex].deviceId;
                    
                    // Get video element
                    const videoElement = document.getElementById('video');
                    
                    // Start decoding from the new camera
                    codeReader.decodeFromVideoDevice(nextDeviceId, videoElement, (result, error) => {
                        if (result) {
                            // Barcode found!
                            const barcode = result.getText();
                            document.getElementById('scannerResult').textContent = `Found barcode: ${barcode}`;
                            
                            // Look up product by barcode
                            const product = products.find(p => p.barcode === barcode);
                            if (product) {
                                handleProductFoundByBarcode(product);
                            } else {
                                // No product found with this barcode
                                document.getElementById('productResult').innerHTML = `
                                    <div class="alert alert-warning mt-3">
                                        <p>Product with barcode ${barcode} not found</p>
                                        <button class="btn btn-primary" onclick="assignBarcodeToNewProduct('${barcode}')">Create New Product</button>
                                        <button class="btn btn-secondary" onclick="showBarcodeAssignmentModal('${barcode}')">Assign to Existing Product</button>
                                    </div>
                                `;
                            }
                        }
                        
                        if (error && !(error instanceof window.NotFoundException)) {
                            // Only log critical errors, not the common "not found" errors
                            console.error('ZXing error:', error);
                        }
                    });
                    
                    document.getElementById('scanner-status').textContent = `Using camera ${currentCameraIndex + 1} of ${availableCameras.length}`;
                })
                .catch(err => {
                    console.error('Error accessing cameras:', err);
                    alert('Error accessing cameras: ' + err);
                });
        }

        // Handle product found by barcode
        function handleProductFoundByBarcode(product) {
            // Display product info
            document.getElementById('productResult').innerHTML = `
                <div class="alert alert-success mt-3">
                    <h4>${product.name}</h4>
                    <p>Price: ${product.price}</p>
                    <p>Stock: ${product.stock}</p>
                </div>
            `;
            
            // Set the product name in the search bar
            document.getElementById('searchInput').value = product.name;
            
            // Automatically stop scanning after finding a valid barcode
            closeBarcodeScanner();
            
            // Update the table to show filtered results
            updateTable();
        }

        // Pending Invoices Functions
        function checkPendingInvoices() {
            const pendingInvoicesList = document.getElementById('pendingInvoicesList');
            pendingInvoicesList.innerHTML = '';
            
            // Get all localStorage keys that match the pattern
            const pendingInvoices = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('avon-temp-')) {
                    try {
                        const value = JSON.parse(localStorage.getItem(key));
                        if (value && value.invoiceNumber && Array.isArray(value.products)) {
                            pendingInvoices.push({
                                key,
                                date: key.replace('avon-temp-', ''),
                                data: value
                            });
                        }
                    } catch (e) {
                        console.error('Error parsing invoice data:', e);
                    }
                }
            }

            // Sort invoices by date (newest first)
            pendingInvoices.sort((a, b) => new Date(b.date) - new Date(a.date));

            if (pendingInvoices.length === 0) {
                document.getElementById('pendingInvoices').style.display = 'none';
                return;
            }

            document.getElementById('pendingInvoices').style.display = 'block';

            // Create invoice groups
            pendingInvoices.forEach(invoice => {
                const invoiceGroup = document.createElement('div');
                invoiceGroup.className = 'invoice-group';

                console.log(invoice.data);
                
                // date format: 04062025
                const date = new Date(invoice.data.invoiceDate.replace(/(\d{2})(\d{2})(\d{4})/, '$3-$2-$1'));
                const formattedDate = formatDate(date.toISOString());
                
                const total = invoice.data.products.reduce((sum, product) => 
                    sum + (parseFloat(product.pretUnitar) * parseInt(product.bucati)), 0);

                invoiceGroup.innerHTML = `
                    <div class="invoice-header" onclick="toggleInvoiceContent(this)">
                        <h3>Invoice #${invoice.data.invoiceNumber} - ${formattedDate}</h3>
                        <span class="toggle-icon">‚ñº</span>
                    </div>
                    <div class="invoice-content">
                        <div class="invoice-products">
                            ${invoice.data.products.map(product => `
                                <div class="invoice-product">
                                    <div class="invoice-product-info">
                                        <div class="invoice-product-name">${product.nume}</div>
                                        <div class="invoice-product-details">
                                            Quantity: ${product.bucati} √ó ${parseFloat(product.pretUnitar).toFixed(2)} RON
                                        </div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <div class="invoice-total">
                            Total: ${total.toFixed(2)} RON
                        </div>
                        <div class="invoice-actions">
                            <button onclick="confirmInvoice('${invoice.key}')" class="btn btn-primary">Add to Inventory</button>
                            <button onclick="deleteInvoice('${invoice.key}')" class="btn btn-secondary">Delete</button>
                        </div>
                    </div>
                `;
                
                pendingInvoicesList.appendChild(invoiceGroup);
            });
        }

        function toggleInvoiceContent(header) {
            const content = header.nextElementSibling;
            const icon = header.querySelector('.toggle-icon');
            
            content.classList.toggle('expanded');
            icon.textContent = content.classList.contains('expanded') ? '‚ñº' : '‚ñ∂';
        }

        async function confirmInvoice(key) {
            try {
                const invoiceData = JSON.parse(localStorage.getItem(key));
                if (!invoiceData || !invoiceData.products) {
                    throw new Error('Invalid invoice data');
                }

                // Process each product in the invoice
                for (const product of invoiceData.products) {
                    // Check if product exists
                    let existingProduct = products.find(p => 
                        p.name.toLowerCase() === product.nume.toLowerCase()
                    );

                    if (!existingProduct) {
                        // Create new product
                        existingProduct = {
                            id: Date.now().toString(),
                            name: product.nume,
                            price: parseFloat(product.pretUnitar),
                            comments: '',
                            barcode: ''
                        };
                        products.push(existingProduct);
                    }

                    // Add to inventory
                    const quantity = parseInt(product.bucati);
                    let inventoryEntry = inventoryItems.find(item => 
                        item.productId === existingProduct.id && 
                        item.locationId === currentLocation
                    );

                    if (inventoryEntry) {
                        // Update existing inventory
                        const oldQuantity = inventoryEntry.quantity;
                        inventoryEntry.quantity += quantity;
                        
                        await addToHistory({
                            type: 'update_quantity',
                            productId: existingProduct.id,
                            productName: existingProduct.name,
                            locationId: currentLocation,
                            oldQuantity,
                            newQuantity: inventoryEntry.quantity,
                            timestamp: new Date().toISOString()
                        });
                    } else {
                        // Create new inventory entry
                        inventoryEntry = {
                            id: Date.now().toString(),
                            productId: existingProduct.id,
                            locationId: currentLocation,
                            quantity: quantity
                        };
                        inventoryItems.push(inventoryEntry);
                        
                        await addToHistory({
                            type: 'add_inventory',
                            productId: existingProduct.id,
                            productName: existingProduct.name,
                            locationId: currentLocation,
                            quantity: quantity,
                            timestamp: new Date().toISOString()
                        });
                    }
                }

                // Save changes
                await save();
                
                // Remove from localStorage
                localStorage.removeItem(key);
                
                // Update UI
                updateTable();
                checkPendingInvoices();
                
                alert('Invoice products have been added to inventory successfully!');
            } catch (error) {
                console.error('Error processing invoice:', error);
                alert('Error processing invoice: ' + error.message);
            }
        }

        function deleteInvoice(key) {
            if (confirm('Are you sure you want to delete this invoice?')) {
                localStorage.removeItem(key);
                checkPendingInvoices();
            }
        }

        // Add checkPendingInvoices to the initialization
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize with error handling
            initializeData().catch(error => {
                console.error('Error during initialization:', error);
                alert('Failed to initialize the application. Please refresh the page or check console for details.');
            });
            
            // Check for pending invoices
            checkPendingInvoices();
        });

        function zoomFloorPlan(delta) {
            const oldScale = stage.scaleX();
            const newScale = oldScale + delta;
            
            // Limit zoom level between 0.1 and 3
            if (newScale >= 0.1 && newScale <= 3) {
                const center = {
                    x: stage.width() / 2,
                    y: stage.height() / 2
                };
                
                const mousePointTo = {
                    x: (center.x - stage.x()) / oldScale,
                    y: (center.y - stage.y()) / oldScale,
                };
                
                stage.scale({ x: newScale, y: newScale });
                
                const newPos = {
                    x: center.x - mousePointTo.x * newScale,
                    y: center.y - mousePointTo.y * newScale,
                };
                
                stage.position(newPos);
                stage.batchDraw();
                
                // Update zoom level display
                currentZoom = Math.round(newScale * 100);
                document.getElementById('zoomLevel').textContent = `${currentZoom}%`;
            }
        }

        function resetZoom() {
            stage.scale({ x: 1, y: 1 });
            stage.position({ x: 0, y: 0 });
            stage.batchDraw();
            
            // Update zoom level display
            currentZoom = 100;
            document.getElementById('zoomLevel').textContent = `${currentZoom}%`;
        }

        // Render location filter buttons
        function renderLocationFilterButtons() {
            const container = document.getElementById('locationFilterButtons');
            if (!container) return;
            container.innerHTML = '';
            if (!locations || locations.length === 0) return;
            locations.forEach(loc => {
                const btn = document.createElement('button');
                btn.textContent = loc.name;
                btn.className = 'location-filter-btn' + (locationFilter === loc.id ? ' selected' : '');
                btn.onclick = () => {
                    locationFilter = loc.id;
                    renderLocationFilterButtons();
                    updateTable();
                };
                container.appendChild(btn);
            });
        }

    </script>
</body>
</html> 